\documentclass[color=usenames,dvipsnames]{beamer}
%\documentclass[color=usenames,dvipsnames,handout]{beamer}

\usepackage[roman]{../lectures}
%\usepackage[sans]{../lectures}


\hypersetup{pdfpagemode=UseNone,pdfstartview={FitV}}



% Load function to compile and open PDF
<<build-fun,include=FALSE,purl=FALSE>>=
source("../rnw2pdf.R")
@

% Compile and open PDF
<<buildit,include=FALSE,eval=FALSE>>=
rnw2pdf("lecture-cap-recap-spatial-II")
rnw2pdf("lecture-cap-recap-spatial-II", tangle=TRUE)
@ 

<<knitr-theme,include=FALSE,purl=FALSE>>=
knit_theme$set("edit-kwrite")
@

% New command for inline code that isn't to be evaluated
\definecolor{inlinecolor}{rgb}{0.878, 0.918, 0.933}
\newcommand{\inr}[1]{\colorbox{inlinecolor}{\texttt{#1}}}




\newcommand{\bxt}{${\bm x}_j$}
\newcommand{\bx}{{\bm x}}
\newcommand{\bxj}{{\bm x}_j}
\newcommand{\bst}{${\bm s}_i$}
\newcommand{\bs}{{\bm s}}
\newcommand{\bsi}{{\bm s}_i}
\newcommand{\ed}{\|\bx - \bs\|}
\newcommand{\cs}{\mathcal{S} }
\newcommand{\dsixj}{\|\bsi - \bxj\|}


\begin{document}




\begin{frame}[plain]
  \LARGE
  \centering
  {
    \LARGE Lecture 12 -- Spatial capture-recapture \\
    for closed populations: \\
    \Large Part II: mapping density surfaces \\
  }
  {\color{default} \rule{\textwidth}{0.1pt} }
  \vfill
  \large
  WILD(FISH) 8390 \\
  Estimation of Fish and Wildlife Population Parameters \\
  \vfill
  \large
  Richard Chandler \\
  University of Georgia \\
\end{frame}






\section{Overview}



\begin{frame}[plain]
  \frametitle{Outline}
  \Large
  \only<1>{\tableofcontents}%[hideallsubsections]}
  \only<2 | handout:0>{\tableofcontents[currentsection]}%,hideallsubsections]}
\end{frame}




\begin{frame}
  \frametitle{SCR overview}
  Last time, we focused on simulation and basic model fitting. \\
  \pause \vfill
  This time, we're going to talk about estimating and mapping density surfaces. \\
%  \pause \vfill
%  And you'll learn how to create maps of 
\end{frame}



\begin{frame}
  \frametitle{SCR overview}
  {\centering Two motivations for SCR \\}
  \vfill
  \begin{enumerate}
    \item Improved inference
    \begin{itemize}
      \item<1-> Non-spatial models can't properly account for sources
        of variation in $p$ that can cause bias.
        \begin{itemize}
          \item<1-> Distance to traps
          \item<1-> Trap-specific covariates
        \end{itemize}
      \item<1-> SCR makes it possible to estimate \alert{density}, not
        just $N$ in an unknown region. 
    \end{itemize}
%    \pause
    \vfill
  \item<1-> Improved science
  \begin{itemize}
    \item<1-> We can ask new questions, such as:
      \begin{itemize}
        \item<1-> What influences spatial variation in density?
        \item<1-> How do survival and recruitment vary in space and time?
        \item<1-> How does movement influence density and detectability?
      \end{itemize}
    \item<1-> Rather than think of SCR as a new estimation tool, you
      can think of it as an individual-based framework for inference on
      spatial population dynamics.
    \end{itemize}
  \end{enumerate}
\end{frame}




% \begin{frame}
%   \frametitle{In-class exercise}
%   Building off the previous example\dots
%   \begin{enumerate}
%     \item Compute $\bar{p}$ for line-transect sampling when
%       $\sigma=50, 100, \mathrm{and}\, 200$, instead of $\sigma=25$.  
%     \item Repeat, but for point-transect sampling. 
%   \end{enumerate}
% \end{frame}





\begin{frame}
  \frametitle{\large Closed population model ($N$ known hypothetically) }
  \footnotesize
  State model (a spatial point process model) %\\
  \begin{gather*}
    \lambda(\bs) = \beta_0 + \beta_1 w_1(\bs) + \beta_2 w_2(\bs) \dots \\
    \Lambda = \int_{\mathcal{S}} \lambda(\bs) \; \mathrm{d}\bs \\
    N \sim \mathrm{Pois}(\Lambda) \\
    \bsi \propto p(\lambda(\bs)) \;\; \mathrm{for}\; i=1,\dots,N 
  \end{gather*}
%  \pause
%  \vfill
  Observation model (supposing $N$ was known)
  \begin{gather*}
    p_{ij} = g_0\exp(-\|\bsi - \bxj\|^2/(2\sigma^2))  \;\; \mathrm{for}\, j=1,\dots,J  \\
    y_{ijk} \sim \mathrm{Bernoulli}(p_{ij})
  \end{gather*}
%  \pause
%  \vfill
%  \footnotesize
  \scriptsize
  Definitions \\
  \hangindent=0.9cm $\lambda(\bs)$ -- The ``intensity function'' %or ``density surface''
  describing the density of individuals at location $\bs$ \\ 
  $\Lambda$ -- Expected number of individuals \\
  $N$ -- Realized number of individuals (ie, population size) \\
  $\bsi$ -- Location of the $i$th activity center \\
  $\bxj$ -- Location of trap $j$ \\
  $\dsixj$ -- Euclidean distance between $\bsi$ and $\bxj$ \\
  $g_0$ -- Capture probability when distance between activity centers
  and traps is 0 \\
  $\sigma$ -- Scale parameter of encounter function \\
  $p_{ij}$ -- Capture probability \\
  $y_{ijk}$ -- Spatial capture histories \\
\end{frame}







\section{Simulation}


\begin{frame}
  \frametitle{Outline}
  \Large
%  \tableofcontents[currentsection,currentsubsection]
  \tableofcontents[currentsection]
\end{frame}






\begin{frame}[fragile]
  \frametitle{Inhomogeneous Poisson point process}
  First, let's import a raster layer
<<ippp1,size='footnotesize',fig.width=7.2,out.width="60%",fig.align="center",results="hide">>=
library(raster)
elevation <- raster("elevation.tif")
plot(elevation, col=topo.colors(100), main="Elevation")
@
\end{frame}




\begin{frame}[fragile]
  \frametitle{Inhomogeneous Poisson point process}
  \small
  Second, let's pick some coefficients and create a density surface
<<ippp2,size='footnotesize',fig.width=7.2,out.width="60%",fig.align="center">>=
beta0 <- -15
beta1 <- 0.01 #0.005
lambda <- exp(beta0 + beta1*elevation) # Intensity function
plot(lambda, col=terrain.colors(100), main="Density surface")
@
\end{frame}




\begin{frame}[fragile]
  \frametitle{Inhomogeneous Poisson point process}
  \small
  Third, simulate $N$
  \vspace{-6pt}
<<ippp3,size='footnotesize'>>=
set.seed(538)  
ds <- 1                            ## Pixel area is 1 ha
lambda.values <- values(lambda)    ## Convert raster to vector
Lambda <- sum(lambda.values*ds)    ## E(N)
(N <- rpois(1, Lambda))            ## Realized N
@
\pause
\vfill
Fourth, simulate and $\bs_1, \dots, \bs_N$. To do this, we'll pick
pixels proportional to density. Then we'll jitter each point
inside its pixel. 
  \vspace{-6pt}
<<ipp4,size='footnotesize'>>=
n.pixels <- length(lambda)
jitter <- 0.005                    ## Half width of pixel 
s.pixels <- sample(n.pixels, size=N, replace=TRUE,
                   prob=lambda.values/Lambda)
elevation.xyz <- as.data.frame(elevation, xy=TRUE)
s <- elevation.xyz[s.pixels,c("x","y")] +
    cbind(runif(N, -jitter, jitter),runif(N, -jitter, jitter))
@
\end{frame}







\begin{frame}[fragile]
  \frametitle{Inhomogeneous Poisson point process}
<<ippp5,size='scriptsize',fig.width=7.2,out.width="70%",fig.align="center">>=
plot(lambda, col=terrain.colors(100),
     main="Density surface with activity centers")
points(s, pch=16, cex=1, col="blue")
@
\end{frame}






\begin{frame}[fragile]
  \frametitle{Traps}
<<traps1,size='scriptsize',fig.width=7.2,out.width="60%",fig.align="center">>=
x <- cbind(rep(seq(0.15, 0.85, by=0.1), each=8),
           rep(seq(0.15, 0.85, by=0.1), times=8))  ## Trap locations
plot(lambda, col=terrain.colors(100),
     main="Density surface with activity centers and traps")
points(s, pch=16, col="blue") ## Activity center locations
points(x, pch=3)              ## Trap locations
@
\end{frame}





\begin{frame}[fragile]
  \frametitle{Distance between traps and activity centers}
  Compute distances between activity centers ($\bs_1, \dots, \bs_N$)
  and traps ($\bx_1, \dots, \bx_J$).
<<dist1,size='footnotesize'>>=
J <- nrow(x)                 ## nTraps
dist.sx <- matrix(NA, N, J)  
for(i in 1:N) {
    dist.sx[i,] <- sqrt((s[i,1]-x[,1])^2 + (s[i,2]-x[,2])^2)
}
@
\pause
\vfill
  Look at distances between first 4 individuals and first 5 traps.
<<dist2,size='footnotesize'>>=
dist.sx[1:4,1:5]
@

\end{frame}






\begin{frame}[fragile]
  \frametitle{Capture probability}
  Compute capture probability
<<p1,size='footnotesize'>>=
g0 <- 0.2
sigma <- 0.05
p <- g0*exp(-dist.sx^2/(2*sigma^2))
@
\pause
\vfill
  Look at capture probs for first 4 individuals and first 5 traps.
<<p2,size='footnotesize'>>=
print(p[1:4,1:5], digits=3)
@

\end{frame}





\begin{frame}[fragile]
  \frametitle{Capture histories}
  Simulate capture histories for all $N$ individuals
<<y1,size='footnotesize'>>=
K <- 5                          # nOccasions
y.all <- array(NA, c(N, J, K))
for(i in 1:N) {
    for(j in 1:J) {
        y.all[i,j,] <- rbinom(K, 1, prob=p[i,j])
    }
}
@
\pause
\vfill
  Discard individuals not captured
<<y2,size='footnotesize'>>=
captured <- rowSums(y.all)>0
y <- y.all[captured,,]
@
\pause
\vfill
  Capture histories for first 2 individuals and first 5 traps
  on first occasion.
<<y3,size='footnotesize'>>=
y[1:2,1:5,1]
@
\end{frame}







\section{Likelihood}



\begin{frame}
  \frametitle{Outline}
  \Large
  \tableofcontents[currentsection]
\end{frame}






<<write,include=FALSE,results="hide">>=
ch.out <- data.frame(session=1,
                     individual=rep(slice.index(y, 1), y),
                     occasion=rep(slice.index(y, 3), y),
                     trap=rep(slice.index(y, 2), y))
write.table(ch.out, file="encounter_data_file.csv",
            row.names=FALSE, col.names=FALSE, sep=",")
traps.out <- data.frame(trap=1:nrow(x), x*1000)
write.table(traps.out, file="trap_data_file.csv",
            row.names=FALSE, col.names=FALSE, sep=",")
library(secr)
@ 


\begin{frame}[fragile]
  \frametitle{R package `secr'}
  \footnotesize
  Import data from two text files.
  <<secr-in,warning=FALSE,size='scriptsize',results='hide',message=FALSE>>=
library(secr)  
sch <- read.capthist(captfile="encounter_data_file.csv",
                     trapfile="trap_data_file.csv",
                     detector="proximity", fmt="trapID")
@
  \pause
  Create the ``habitat mask'', which defines the state-space and the
  spatial covariates. First, prepare the elevation covariate. 
<<format-elevation,size='scriptsize'>>=
elevation.xyz <- as.data.frame(elevation, xy=TRUE)
elevation.xyz.m <- elevation.xyz
elevation.xyz.m$x <- elevation.xyz$x*1000  ## Convert units to meters
elevation.xyz.m$y <- elevation.xyz$y*1000
elevation.xyz.m$elevation <- scale(elevation.xyz$elevation) ## Standardize
elevation.m <- rasterFromXYZ(elevation.xyz.m)
@
  \pause
  Now create the mask.
<<make-mask,size='scriptsize'>>=
library(sp)
elev.sp <- as(elevation.m, "SpatialGridDataFrame")
trp <- traps(sch)
mask <- make.mask(trp, buffer=150, spacing=15)
mask <- addCovariates(mask, spatialdata=elev.sp)
@   
\end{frame}


\begin{frame}[fragile]
  \frametitle{Habitat mask}
<<plot-mask,fig.height=5,out.width="95%",fig.align='center',echo=-1,size='scriptsize'>>=
par(mai=c(0.1, 0.1, 0.1, 0.1))
plot(mask, covariate="elevation")
plot(trp, add=TRUE)
@   
\end{frame}




\begin{frame}[fragile]
  \frametitle{R package `secr'}
  Model density as a function of elevation. 
<<secr-elev,size='scriptsize',cache=TRUE>>=
fm.elev <- secr.fit(sch, model=list(D=~elevation, g0=~1, sigma=~1),
                    mask=mask, trace=FALSE) ## Don't use 'buffer'
coef(fm.elev)
@
\pause
\vfill
Estimates on original scale (at average covariate values).
<<secr-M0-real,size='scriptsize'>>=
predict(fm.elev)
@
\end{frame}



\begin{frame}[fragile]
  \frametitle{Estimated density surface}
<<secr-dsurf,size='scriptsize',fig.height=6.8,echo=-1,size='scriptsize',fig.show='hide'>>=
#par(mai=c(0.6,0.6,0.1,0.8))
dsurf <- predictDsurface(fm.elev)
dsurf.r <- raster(dsurf, covariate="D.0")
plot(dsurf.r, col=terrain.colors(100), main="Estimated density surface")
@
\centering
\includegraphics[width=0.49\textwidth]{figure/secr-dsurf-1}
\includegraphics[width=0.49\textwidth]{figure/ippp2-1} \\
\pause \vfill
The units differ because we transformed to meters. \\
\end{frame}



\begin{frame}[fragile]
  \frametitle{Estimated activity center locations}
<<fxi,eval=FALSE,size='scriptsize'>>=
plot(trp)
fxi.contour(fm.elev)#, X=mask[,c("x","y")], p=c(0.95, 0.99))
fxi.contour(fm0)#,i=2,add=TRUE,plotmode=FALSE,drawlabels = FALSE, X=mask[,c("x","y")])
@   
\end{frame}




\begin{frame}[fragile]
  \frametitle{R package `secr'}
  We can still estimate $N$ as before. \\
  \vfill
  \inr{E.N} is the expected value of
  $N$. \inr{R.N} is the realized value of $N$. 
  \vfill
<<regionN-M0,size='small'>>=
region.N(fm.elev)
@
\end{frame}




\section{Data augmentation}


%\section{Prediction}
%\subsection{Likelihood-based inference}


\begin{frame}
  \frametitle{Outline}
  \Large
  \tableofcontents[currentsection]
\end{frame}





\begin{frame}
  \frametitle{Data augmentation model}
  The DA version of a SCR model with an inhomogeneous point process
  can be written like this:
  \begin{gather*}
    \lambda(\bs) = \exp(\beta_0 + \beta_1 \mathrm{ELEV}(\bs)) \\
    \bsi \propto (\lambda(\bs)) \\
    z_i \sim \mathrm{Bern}(\psi) \\
    p_{ij} = g_0\exp(-\|\bsi-\bxj\|^2/(2\sigma^2)) \\
    y_{ijk} \sim \mathrm{Bern}(z_i p_{ij}) \\
    N=\sum_{i=1}^M z_i
  \end{gather*}
  % A uniform prior on $\psi$ results in a discrete uniform prior on
  % $N$. We can change the prior for $N$ by changing the prior on
  % $\psi$, recognizing that $E(N)=M\psi$.
  % But why bother with augmentation?
  % \begin{itemize}
  %   \item DA works for \alert{all} varieties of mark-recapture models
  %   \item Make it easy to incorporate
  %     individual-covariates\dots\pause including distance and
  %     location!   
  % \end{itemize}
\end{frame}



\begin{frame}
  \frametitle{Inhomogeneous point process in JAGS}
  We need to do the following to make this work:
  \begin{enumerate}
    \item Provide the spatial covariate as a vector
    \item Loop over all pixels to compute the density at each pixel
    \item Retain the uniform prior on the activity centers, but add a
      second probability component to force them to be distributed
      according to the density surface.
      \begin{enumerate}
        \item This requires that we create a ``lookup'' table to map
          points in space to pixel IDs
        \item Then we use the ``zero's trick'' to implement the
          non-standard probability distribution
      \end{enumerate}
    \item Define $\psi=E(N)/M$
  \end{enumerate}
\end{frame}




\begin{frame}[fragile]
  \frametitle{SCR with inhomogeneous PP and data augmentation}
\vspace{-3pt}
<<bugs-SCR-elev,size='scriptsize'>>=
writeLines(readLines("SCR-elev.jag"))
@
\end{frame}


<<rjags,include=FALSE,results="hide">>=
library(rjags)
@ 



\begin{frame}[fragile]
  \frametitle{SCR with IPP}
  Create the lookup table
<<lookup,size='scriptsize'>>=
G <- nrow(elevation.xyz)    ## nPixels  
lookup <- matrix(1:G, nrow=nrow(elevation), ncol=ncol(elevation))
delta <- res(elevation)[1]  ## resolution
@   
\end{frame}


\begin{frame}[fragile]
  \frametitle{SCR with IPP}
  Data
  \vspace{-6pt}
<<jd-SCR-elev-faster,size='scriptsize'>>=
M <- 150  
y.tilde <- apply(y, c(1,2), sum)
n <- nrow(y)
jags.data.SCR.elev <- list(y.tilde=y.tilde, n=n, M=M, J=J,
                           G=G, delta=delta, lookup=lookup,
                           pixelArea=delta^2*1e4, ## Convert to hectares
                           elevation=elevation.xyz$elevation,
                           z=c(rep(1, n), rep(NA, M-n)),
                           zeros=rep(0, M),
                           K=K, zero.cap=rep(0, M), x=x,
                           xlim=c(0,1), ylim=c(0,1))
@
\pause
\vfill
  Inits and parameters (same as before)
<<jp-SCR-elev>>=
jp.SCR.elev <- c("beta0", "beta1", "g0", "sigma", "EN", "N")
@ 
\pause
\vfill
<<ji-M0-aug-faster,size='scriptsize'>>=
ji.SCR.elev <- function() {
    list(z=c(rep(NA, n), rep(0,M-n)), #psi=runif(1),
#         beta0=runif(1, -20, -15),
         beta1=0.01,
         s=cbind(runif(M), runif(M)),
         g0=runif(1), sigma=runif(1, 0.05, 0.1)) }
@
MCMC
  \vspace{-6pt}
<<mcmc-SCR-elev,size='scriptsize',results='hide',cache=TRUE>>=
jags.post.SCR.elev <- jags.basic(data=jags.data.SCR.elev,
                                 inits=ji.SCR.elev,
                                 parameters.to.save=jp.SCR.elev,
                                 model.file="SCR-elev.jag",
                                 n.chains=3, n.adapt=100, 
                                 n.iter=1000, parallel=TRUE)
@ 
\end{frame}




\begin{frame}[fragile]
  \frametitle{Posterior summaries}
<<summary-mcmc-SCR0-faster,size='tiny'>>=
summary(jags.post.SCR.elev)
@ 
\end{frame}



\begin{frame}[fragile]
  \frametitle{Traceplots and density plots}
<<plot-mcmc-SCR-elev1,size='footnotesize',out.width="0.7\\textwidth",fig.align='center'>>=
plot(jags.post.SCR.elev[,jp.SCR.elev[1:3]])
@ 
\end{frame}



\begin{frame}[fragile]
  \frametitle{Traceplots and density plots}
<<plot-mcmc-SCR-elev2,size='footnotesize',out.width="0.7\\textwidth",fig.align='center'>>=
plot(jags.post.SCR.elev[,jp.SCR.elev[4:6]])
@ 
\end{frame}


\begin{frame}[fragile
  \frametitle{Density surfaces in JAGS}
  We need to monitor $z$ and $\bsi$.
<<mcmc-SCR-elev,size='scriptsize',results='hide',cache=TRUE>>=
jags.post.SCR.elev.sz <- jags.basic(data=jags.data.SCR.elev,
                                 inits=ji.SCR.elev,
                                 parameters.to.save=c(jp.SCR.elev,"s","z"),
                                 model.file="SCR-elev.jag",
                                 n.chains=3, n.adapt=100, 
                                 n.iter=1000, parallel=TRUE)
@ 
\end{frame}




\begin{frame}
  \frametitle{Summary}
\end{frame}




\section{Assignment}




\begin{frame}[fragile]
  \frametitle{Assignment}
  Create a self-contained R script or Rmarkdown file to do the
  following: 
  \vfill
  \begin{enumerate}
    \item Fit a ``local behavioral response'' model,
      rather than a ``global behavioral response'' model in secr.
    \item Fit a model in JAGS where $g_0$ varies among
      occasions. Compare estimates of $E(N)$ and $N$ to the estimates
      from secr for the same model (which we fit earlier).
  \end{enumerate}
  \vfill
  Upload your {\tt .R} or {\tt .Rmd} file to ELC before Tuesday. 
\end{frame}





\end{document}

