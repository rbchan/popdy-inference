\documentclass[color=usenames,dvipsnames]{beamer}\usepackage[]{graphicx}\usepackage[]{xcolor}
% maxwidth is the original width if it is less than linewidth
% otherwise use linewidth (to make sure the graphics do not exceed the margin)
\makeatletter
\def\maxwidth{ %
  \ifdim\Gin@nat@width>\linewidth
    \linewidth
  \else
    \Gin@nat@width
  \fi
}
\makeatother

\definecolor{fgcolor}{rgb}{0, 0, 0}
\newcommand{\hlnum}[1]{\textcolor[rgb]{0.69,0.494,0}{#1}}%
\newcommand{\hlsng}[1]{\textcolor[rgb]{0.749,0.012,0.012}{#1}}%
\newcommand{\hlcom}[1]{\textcolor[rgb]{0.514,0.506,0.514}{\textit{#1}}}%
\newcommand{\hlopt}[1]{\textcolor[rgb]{0,0,0}{#1}}%
\newcommand{\hldef}[1]{\textcolor[rgb]{0,0,0}{#1}}%
\newcommand{\hlkwa}[1]{\textcolor[rgb]{0,0,0}{\textbf{#1}}}%
\newcommand{\hlkwb}[1]{\textcolor[rgb]{0,0.341,0.682}{#1}}%
\newcommand{\hlkwc}[1]{\textcolor[rgb]{0,0,0}{\textbf{#1}}}%
\newcommand{\hlkwd}[1]{\textcolor[rgb]{0.004,0.004,0.506}{#1}}%
\let\hlipl\hlkwb

\usepackage{framed}
\makeatletter
\newenvironment{kframe}{%
 \def\at@end@of@kframe{}%
 \ifinner\ifhmode%
  \def\at@end@of@kframe{\end{minipage}}%
  \begin{minipage}{\columnwidth}%
 \fi\fi%
 \def\FrameCommand##1{\hskip\@totalleftmargin \hskip-\fboxsep
 \colorbox{shadecolor}{##1}\hskip-\fboxsep
     % There is no \\@totalrightmargin, so:
     \hskip-\linewidth \hskip-\@totalleftmargin \hskip\columnwidth}%
 \MakeFramed {\advance\hsize-\width
   \@totalleftmargin\z@ \linewidth\hsize
   \@setminipage}}%
 {\par\unskip\endMakeFramed%
 \at@end@of@kframe}
\makeatother

\definecolor{shadecolor}{rgb}{.97, .97, .97}
\definecolor{messagecolor}{rgb}{0, 0, 0}
\definecolor{warningcolor}{rgb}{1, 0, 1}
\definecolor{errorcolor}{rgb}{1, 0, 0}
\newenvironment{knitrout}{}{} % an empty environment to be redefined in TeX

\let\hlstd\hldef
\let\hlstr\hlsng
\usepackage{alltt}
%\documentclass[color=usenames,dvipsnames,handout]{beamer}

\usepackage[roman]{../lectures}
%\usepackage[sans]{../lectures}

\usepackage{pgffor}% http://ctan.org/pkg/pgffor


\hypersetup{pdfpagemode=UseNone,pdfstartview={FitV}}

\mode<handout>{
  \usetheme{default}
%  \setbeamercolor{background canvas}{bg=black!5}
%  \pgfpagesuselayout{4 on 1}[letterpaper,landscape,border shrink=2.5mm]
%  \pgfpagesuselayout{2 on 1}[letterpaper,border shrink=10mm]
}


% Load function to compile and open PDF


% Compile and open PDF




% New command for inline code that isn't to be evaluated
\definecolor{inlinecolor}{rgb}{0.878, 0.918, 0.933}
\newcommand{\inr}[1]{\colorbox{inlinecolor}{\texttt{#1}}}
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\begin{document}




\begin{frame}[plain]
  \LARGE
  \centering
  {
    \LARGE Spatial capture-recapture for \\
    closed populations: Part II \\
    \Large Mapping density surfaces and activity centers \\
  }
  {\color{default} \rule{\textwidth}{0.1pt} }
  \vfill
  \large
  WILD(FISH) 8390 \\
%  Estimation of Fish and Wildlife Population Parameters \\
  Inference for Models of Fish and Wildlife Population Dynamics \\
  \vfill
  \large
  Richard Chandler \\
  University of Georgia \\
\end{frame}






\section{Overview}



\begin{frame}[plain]
  \frametitle{Outline}
  \Large
  \only<1>{\tableofcontents}%[hideallsubsections]}
  \only<2 | handout:0>{\tableofcontents[currentsection]}%,hideallsubsections]}
\end{frame}




% \begin{frame}
%   \frametitle{SCR overview}
%   Last time, we focused on simulation and basic model fitting. \\
%   \pause \vfill
%   This time, we're going to talk about estimating and mapping density surfaces. \\
% %  \pause \vfill
% %  And you'll learn how to create maps of 
% \end{frame}



% \begin{frame}
%   \frametitle{SCR overview}
%   {\centering Two motivations for SCR \\}
%   \vfill
%   \begin{enumerate}
%     \item Improved inference
%     \begin{itemize}
%       \item<1-> Non-spatial models can't properly account for sources
%         of variation in $p$ that can cause bias.
%         \begin{itemize}
%           \item<1-> Distance to traps
%           \item<1-> Trap-specific covariates
%         \end{itemize}
%       \item<1-> SCR makes it possible to estimate \alert{density}, not
%         just $N$ in an unknown region. 
%     \end{itemize}
% %    \pause
%     \vfill
%   \item<1-> Improved science
%   \begin{itemize}
%     \item<1-> We can ask new questions, such as:
%       \begin{itemize}
%         \item<1-> What influences spatial variation in density?
%         \item<1-> How do survival and recruitment vary in space and time?
%         \item<1-> How does movement influence density and detectability?
%       \end{itemize}
%     \item<1-> Rather than think of SCR as a new estimation tool, you
%       can think of it as an individual-based framework for inference on
%       spatial population dynamics.
%     \end{itemize}
%   \end{enumerate}
% \end{frame}




% \begin{frame}
%   \frametitle{In-class exercise}
%   Building off the previous example\dots
%   \begin{enumerate}
%     \item Compute $\bar{p}$ for line-transect sampling when
%       $\sigma=50, 100, \mathrm{and}\, 200$, instead of $\sigma=25$.  
%     \item Repeat, but for point-transect sampling. 
%   \end{enumerate}
% \end{frame}





\begin{frame}
  \frametitle{\large Closed population model ($N$ known hypothetically) }
  \footnotesize
  State model (a spatial point process model) %\\
  \begin{gather*}
    \lambda(\bs) = \exp(\beta_0 + \beta_1 w_1(\bs) + \beta_2 w_2(\bs)) \dots \\
    \Lambda = \int_{\mathcal{S}} \lambda(\bs) \; \mathrm{d}\bs \\
    N \sim \mathrm{Pois}(\Lambda) \\
    \bsi \propto p(\lambda(\bs)) \;\; \mathrm{for}\; i=1,\dots,N 
  \end{gather*}
%  \pause
%  \vfill
  Observation model (supposing $N$ was known)
  \begin{gather*}
    p_{ij} = g_0\exp(-\|\bsi - \bxj\|^2/(2\sigma^2))  \;\; \mathrm{for}\, j=1,\dots,J  \\
    y_{ijk} \sim \mathrm{Bernoulli}(p_{ij})
  \end{gather*}
%  \pause
%  \vfill
%  \footnotesize
  \scriptsize
  Definitions \\
  \hangindent=0.9cm $\lambda(\bs)$ -- The ``intensity function'' %or ``density surface''
  describing the density of individuals at location $\bs$ \\ 
  $\Lambda$ -- Expected number of individuals in the spatial region $\cal S$ \\
  $N$ -- Realized number of individuals (ie, population size) \\
  $\bsi$ -- Location of the $i$th activity center \\
  $\bxj$ -- Location of trap $j$ \\
  $\dsixj$ -- Euclidean distance between $\bsi$ and $\bxj$ \\
  $g_0$ -- Capture probability when distance between activity centers
  and traps is 0 \\
  $\sigma$ -- Scale parameter of encounter function \\
  $p_{ij}$ -- Capture probability \\
  $y_{ijk}$ -- Spatial capture histories \\
\end{frame}




\begin{frame}
  \frametitle{Spatial point processes}
  {\centering \large
    The state model of SCR is a spatial (or spatio-temporal) point process \\}
  \vfill
  \pause
  There are many varieties of spatial point processes, including \\
  \begin{itemize}
    \item (In)homogeneous binomial point process
    \item (In)homogeneous Poisson point process
    \item Cox process
    \item Gibbs process
    \item Markov point process
%    \item Among others
  \end{itemize}
\end{frame}





\begin{frame}
  \frametitle{Spatial point processes}
%  \large
  All share a few properties \\
  \begin{itemize}%[<+->]
    \item<1-> The data are a collection of points called a ``point pattern''
    \item<2-> Points are in an area called the state-space
      ($\mathcal{S}$), or observation window, which is usually two
      dimensional  
    \item<3-> An intensity function ($\lambda(\bs)$) describes spatial
      variation in the density of points
    \item<4-> The area under this function is the expected number of
      points (a.k.a, $N$) in the region:
  \end{itemize}
  \vfill
%  \Large
  \uncover<5->{
\[
  E(N) = \Lambda = \int_{\mathcal{S}} \lambda(\bs) \;\mathrm{d}\bs
\]
}
\end{frame}



\begin{frame}
  \frametitle{Poisson point process}
  Properties
  \begin{itemize}
    \item If density is constant throughout the state-space:
      $\lambda(\bs) = \lambda$, the process is said to be
      ``homogeneous''
    \item Otherwise, the process is ``inhomogeneous''
    \item The number of points in any region of the state-space is
      Poisson distributed
    \item Points are independent of one another (no attraction or
      repulsion) 
  \end{itemize}
  \pause
  \vfill
%   \centering {\bf Note:} For more complicated models, it's easier to
%   work in discrete space than continuous space. Plus, spatial
%   covariates always come to us in the form of raster. \\
  An inhomogeneous point process allows for spatial variation
  in density, which can be modeled using \alert{spatial covariates},
  such as raster layers. \\
\end{frame}






\begin{frame}
  \frametitle{Density surfaces}
  \large
  We can use a fitted model to make maps of the following: 
  \begin{enumerate}
    \item<1-> Expected density surface%, $\lambda(\bs)$
    \begin{itemize}
      \item This is an estimate of $\lambda(\bs)$.
      \item It's the expected value of density at  each location.
      \item It's good for describing and predicting density at a
        different point in time, assuming the processes controlling
        density don't change.
    \end{itemize}
    \item<2-> Realized density surface%,
%      $\sum_i \bsi \in \mathcal{B} \subset \mathcal{S}$
      \begin{itemize}
        \item This is an estimate of the number of activity centers
          per unit area \alert{during the sampling period}.
        \item It's an estimate of the realized point pattern.
        \item It will be equivalent to the expected density surface
          far from the traps. 
      \end{itemize}
    \item<3-> Activity center locations%, $\bsi$
      \begin{itemize}
        \item The posterior distribution of each activity center.
        \item This is not a home range map.
      \end{itemize}
  \end{enumerate}
\end{frame}



\section{Simulation}


\begin{frame}
  \frametitle{Outline}
  \Large
%  \tableofcontents[currentsection,currentsubsection]
  \tableofcontents[currentsection]
\end{frame}






\begin{frame}[fragile]
  \frametitle{Inhomogeneous Poisson point process}
  First, let's import a raster layer
\begin{knitrout}\scriptsize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hldef{(raster)}
\hldef{elevation} \hlkwb{<-} \hlkwd{raster}\hldef{(}\hlsng{"elevation.tif"}\hldef{)}
\hldef{delta} \hlkwb{<-} \hlkwd{res}\hldef{(elevation)[}\hlnum{1}\hldef{]}  \hlcom{## resolution}
\hlkwd{plot}\hldef{(elevation,} \hlkwc{col}\hldef{=}\hlkwd{topo.colors}\hldef{(}\hlnum{100}\hldef{),} \hlkwc{main}\hldef{=}\hlsng{"Elevation"}\hldef{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=0.6\linewidth]{figure/ippp1-1} 

}


\end{knitrout}
\end{frame}




\begin{frame}[fragile]
  \frametitle{Inhomogeneous Poisson point process}
  \small
  Second, let's pick some coefficients and create a density surface
\begin{knitrout}\tiny
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hldef{beta0} \hlkwb{<-} \hlopt{-}\hlnum{15}
\hldef{beta1} \hlkwb{<-} \hlnum{0.01} \hlcom{#0.005}
\hldef{lambda} \hlkwb{<-} \hlkwd{exp}\hldef{(beta0} \hlopt{+} \hldef{beta1}\hlopt{*}\hldef{elevation)} \hlcom{# Intensity function}
\hlkwd{plot}\hldef{(lambda,} \hlkwc{col}\hldef{=}\hlkwd{terrain.colors}\hldef{(}\hlnum{100}\hldef{),} \hlkwc{main}\hldef{=}\hlsng{"Density surface"}\hldef{,} \hlkwc{zlim}\hldef{=}\hlkwd{c}\hldef{(}\hlnum{0}\hldef{,}\hlnum{0.18}\hldef{))}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=0.6\linewidth]{figure/ippp2-1} 

}


\end{knitrout}
\end{frame}




\begin{frame}[fragile]
  \frametitle{Inhomogeneous Poisson point process}
  \small
  Third, simulate $N$
  \vspace{-6pt}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{set.seed}\hldef{(}\hlnum{538}\hldef{)}
\hldef{ds} \hlkwb{<-} \hlnum{1}                          \hlcom{## Pixel area is 1 ha}
\hldef{lambda.values} \hlkwb{<-} \hlkwd{values}\hldef{(lambda)}  \hlcom{## Convert raster to vector}
\hldef{Lambda} \hlkwb{<-} \hlkwd{sum}\hldef{(lambda.values}\hlopt{*}\hldef{ds)}  \hlcom{## E(N)}
\hldef{(N} \hlkwb{<-} \hlkwd{rpois}\hldef{(}\hlnum{1}\hldef{, Lambda))}          \hlcom{## Realized N}
\end{alltt}
\begin{verbatim}
## [1] 98
\end{verbatim}
\end{kframe}
\end{knitrout}
\pause
\vfill
Fourth, simulate $\bs_1, \dots, \bs_N$. To do this, we'll pick
pixels proportional to density. Then we'll jitter each point
inside its pixel. 
  \vspace{-6pt}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hldef{n.pixels} \hlkwb{<-} \hlkwd{length}\hldef{(lambda)}
\hldef{jitter} \hlkwb{<-} \hlnum{0.005}                    \hlcom{## Half width of pixel }
\hldef{s.pixels} \hlkwb{<-} \hlkwd{sample}\hldef{(n.pixels,} \hlkwc{size}\hldef{=N,} \hlkwc{replace}\hldef{=}\hlnum{TRUE}\hldef{,}
                   \hlkwc{prob}\hldef{=lambda.values}\hlopt{/}\hldef{Lambda)}
\hldef{elevation.xyz} \hlkwb{<-} \hlkwd{as.data.frame}\hldef{(elevation,} \hlkwc{xy}\hldef{=}\hlnum{TRUE}\hldef{)}
\hldef{s} \hlkwb{<-} \hldef{elevation.xyz[s.pixels,}\hlkwd{c}\hldef{(}\hlsng{"x"}\hldef{,}\hlsng{"y"}\hldef{)]} \hlopt{+}
    \hlkwd{cbind}\hldef{(}\hlkwd{runif}\hldef{(N,} \hlopt{-}\hldef{jitter, jitter),}\hlkwd{runif}\hldef{(N,} \hlopt{-}\hldef{jitter, jitter))}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{frame}







\begin{frame}[fragile]
  \frametitle{Inhomogeneous Poisson point process}
\begin{knitrout}\scriptsize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{plot}\hldef{(lambda,} \hlkwc{col}\hldef{=}\hlkwd{terrain.colors}\hldef{(}\hlnum{100}\hldef{),}
     \hlkwc{main}\hldef{=}\hlsng{"Density surface with activity centers"}\hldef{)}
\hlkwd{points}\hldef{(s,} \hlkwc{pch}\hldef{=}\hlnum{16}\hldef{,} \hlkwc{cex}\hldef{=}\hlnum{1}\hldef{,} \hlkwc{col}\hldef{=}\hlsng{"blue"}\hldef{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=0.7\linewidth]{figure/ippp5-1} 

}


\end{knitrout}
\end{frame}






\begin{frame}[fragile]
  \frametitle{Traps}
\begin{knitrout}\scriptsize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hldef{x} \hlkwb{<-} \hlkwd{cbind}\hldef{(}\hlkwd{rep}\hldef{(}\hlkwd{seq}\hldef{(}\hlnum{0.15}\hldef{,} \hlnum{0.85}\hldef{,} \hlkwc{by}\hldef{=}\hlnum{0.1}\hldef{),} \hlkwc{each}\hldef{=}\hlnum{8}\hldef{),}
           \hlkwd{rep}\hldef{(}\hlkwd{seq}\hldef{(}\hlnum{0.15}\hldef{,} \hlnum{0.85}\hldef{,} \hlkwc{by}\hldef{=}\hlnum{0.1}\hldef{),} \hlkwc{times}\hldef{=}\hlnum{8}\hldef{))}  \hlcom{## Trap locations}
\hlkwd{plot}\hldef{(lambda,} \hlkwc{col}\hldef{=}\hlkwd{terrain.colors}\hldef{(}\hlnum{100}\hldef{),}
     \hlkwc{main}\hldef{=}\hlsng{"Density surface with activity centers and traps"}\hldef{)}
\hlkwd{points}\hldef{(s,} \hlkwc{pch}\hldef{=}\hlnum{16}\hldef{,} \hlkwc{col}\hldef{=}\hlsng{"blue"}\hldef{)} \hlcom{## Activity center locations}
\hlkwd{points}\hldef{(x,} \hlkwc{pch}\hldef{=}\hlnum{3}\hldef{)}              \hlcom{## Trap locations}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=0.6\linewidth]{figure/traps1-1} 

}


\end{knitrout}
\end{frame}





\begin{frame}[fragile]
  \frametitle{Distance between traps and activity centers}
  Compute distances between activity centers ($\bs_1, \dots, \bs_N$)
  and traps ($\bx_1, \dots, \bx_J$).
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hldef{J} \hlkwb{<-} \hlkwd{nrow}\hldef{(x)}                 \hlcom{## nTraps}
\hldef{dist.sx} \hlkwb{<-} \hlkwd{matrix}\hldef{(}\hlnum{NA}\hldef{, N, J)}
\hlkwa{for}\hldef{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hldef{N) \{}
    \hldef{dist.sx[i,]} \hlkwb{<-} \hlkwd{sqrt}\hldef{((s[i,}\hlnum{1}\hldef{]}\hlopt{-}\hldef{x[,}\hlnum{1}\hldef{])}\hlopt{^}\hlnum{2} \hlopt{+} \hldef{(s[i,}\hlnum{2}\hldef{]}\hlopt{-}\hldef{x[,}\hlnum{2}\hldef{])}\hlopt{^}\hlnum{2}\hldef{)}
\hldef{\}}
\end{alltt}
\end{kframe}
\end{knitrout}
\pause
\vfill
  Look at distances between first 4 individuals and first 5 traps.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hldef{dist.sx[}\hlnum{1}\hlopt{:}\hlnum{4}\hldef{,}\hlnum{1}\hlopt{:}\hlnum{5}\hldef{]}
\end{alltt}
\begin{verbatim}
##           [,1]      [,2]      [,3]      [,4]      [,5]
## [1,] 0.1218625 0.1175070 0.1810119 0.2678109 0.3614970
## [2,] 0.9587743 0.8922040 0.8323508 0.7807610 0.7391668
## [3,] 0.7162980 0.6912027 0.6800289 0.6834600 0.7012815
## [4,] 0.6222620 0.5569781 0.5032288 0.4650310 0.4463949
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{frame}






\begin{frame}[fragile]
  \frametitle{Capture probability}
  Compute capture probability
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hldef{g0} \hlkwb{<-} \hlnum{0.2}
\hldef{sigma} \hlkwb{<-} \hlnum{0.05}
\hldef{p} \hlkwb{<-} \hldef{g0}\hlopt{*}\hlkwd{exp}\hldef{(}\hlopt{-}\hldef{dist.sx}\hlopt{^}\hlnum{2}\hlopt{/}\hldef{(}\hlnum{2}\hlopt{*}\hldef{sigma}\hlopt{^}\hlnum{2}\hldef{))}
\end{alltt}
\end{kframe}
\end{knitrout}
\pause
\vfill
  Look at capture probs for first 4 individuals and first 5 traps.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{print}\hldef{(p[}\hlnum{1}\hlopt{:}\hlnum{4}\hldef{,}\hlnum{1}\hlopt{:}\hlnum{5}\hldef{],} \hlkwc{digits}\hldef{=}\hlnum{3}\hldef{)}
\end{alltt}
\begin{verbatim}
##          [,1]     [,2]     [,3]     [,4]     [,5]
## [1,] 1.03e-02 1.26e-02 2.85e-04 1.18e-07 8.92e-13
## [2,] 2.86e-81 1.44e-70 1.33e-61 2.25e-54 6.98e-49
## [3,] 5.44e-46 6.36e-43 1.36e-41 5.34e-42 3.84e-44
## [4,] 4.66e-35 2.27e-28 2.02e-23 3.29e-20 9.84e-19
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{frame}





\begin{frame}[fragile]
  \frametitle{Capture histories}
  Simulate capture histories for all $N$ individuals
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hldef{K} \hlkwb{<-} \hlnum{5}                          \hlcom{# nOccasions}
\hldef{y.all} \hlkwb{<-} \hlkwd{array}\hldef{(}\hlnum{NA}\hldef{,} \hlkwd{c}\hldef{(N, J, K))}
\hlkwa{for}\hldef{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hldef{N) \{}
    \hlkwa{for}\hldef{(j} \hlkwa{in} \hlnum{1}\hlopt{:}\hldef{J) \{}
        \hldef{y.all[i,j,]} \hlkwb{<-} \hlkwd{rbinom}\hldef{(K,} \hlnum{1}\hldef{,} \hlkwc{prob}\hldef{=p[i,j])}
    \hldef{\}}
\hldef{\}}
\end{alltt}
\end{kframe}
\end{knitrout}
\pause
\vfill
  Discard individuals not captured
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hldef{captured} \hlkwb{<-} \hlkwd{rowSums}\hldef{(y.all)}\hlopt{>}\hlnum{0}
\hldef{y} \hlkwb{<-} \hldef{y.all[captured,,]}
\end{alltt}
\end{kframe}
\end{knitrout}
\pause
\vfill
  Capture histories for first 2 individuals and first 5 traps
  on first occasion.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hldef{y[}\hlnum{1}\hlopt{:}\hlnum{2}\hldef{,}\hlnum{1}\hlopt{:}\hlnum{5}\hldef{,}\hlnum{1}\hldef{]}
\end{alltt}
\begin{verbatim}
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    0    0    0    0    0
## [2,]    0    0    0    0    0
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{frame}







\section{Likelihood}



\begin{frame}
  \frametitle{Outline}
  \Large
  \tableofcontents[currentsection]
\end{frame}









\begin{frame}[fragile]
  \frametitle{R package `secr'}
  \footnotesize
  Import data from two text files.
\begin{knitrout}\scriptsize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hldef{(secr)}
\hldef{sch} \hlkwb{<-} \hlkwd{read.capthist}\hldef{(}\hlkwc{captfile}\hldef{=}\hlsng{"encounter_data_file.csv"}\hldef{,}
                   \hlkwc{trapfile}\hldef{=}\hlsng{"trap_data_file.csv"}\hldef{,}
                   \hlkwc{detector}\hldef{=}\hlsng{"proximity"}\hldef{,} \hlkwc{fmt}\hldef{=}\hlsng{"trapID"}\hldef{)}
\end{alltt}
\end{kframe}
\end{knitrout}
  \pause
  Create the ``habitat mask'', which defines the state-space and the
  spatial covariates. First, prepare the elevation covariate. 
\begin{knitrout}\scriptsize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hldef{elevation.xyz} \hlkwb{<-} \hlkwd{as.data.frame}\hldef{(elevation,} \hlkwc{xy}\hldef{=}\hlnum{TRUE}\hldef{)}
\hldef{elevation.xyz}\hlopt{$}\hldef{y} \hlkwb{<-} \hlkwd{round}\hldef{(elevation.xyz}\hlopt{$}\hldef{y,} \hlnum{3}\hldef{)} \hlcom{## Fix numerical fuzz}
\hldef{elevation.xyz.m} \hlkwb{<-} \hldef{elevation.xyz}
\hldef{elevation.xyz.m}\hlopt{$}\hldef{x} \hlkwb{<-} \hldef{elevation.xyz}\hlopt{$}\hldef{x}\hlopt{*}\hlnum{1000}  \hlcom{## Convert units to meters}
\hldef{elevation.xyz.m}\hlopt{$}\hldef{y} \hlkwb{<-} \hldef{elevation.xyz}\hlopt{$}\hldef{y}\hlopt{*}\hlnum{1000}
\hldef{elevation.xyz.m}\hlopt{$}\hldef{elevation} \hlkwb{<-} \hlkwd{scale}\hldef{(elevation.xyz}\hlopt{$}\hldef{elevation)} \hlcom{## Standardize}
\hldef{elevation.m} \hlkwb{<-} \hlkwd{rasterFromXYZ}\hldef{(elevation.xyz.m)}
\end{alltt}
\end{kframe}
\end{knitrout}
  \pause
  Now create the mask.
\begin{knitrout}\scriptsize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hldef{(sp)}
\hldef{elev.sp} \hlkwb{<-} \hlkwd{as}\hldef{(elevation.m,} \hlsng{"SpatialGridDataFrame"}\hldef{)}
\hldef{trp} \hlkwb{<-} \hlkwd{traps}\hldef{(sch)}
\hldef{mask} \hlkwb{<-} \hlkwd{make.mask}\hldef{(trp,} \hlkwc{buffer}\hldef{=}\hlnum{150}\hldef{,} \hlkwc{spacing}\hldef{=}\hlnum{10}\hldef{)}
\hldef{mask} \hlkwb{<-} \hlkwd{addCovariates}\hldef{(mask,} \hlkwc{spatialdata}\hldef{=elev.sp)}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Habitat mask}
\begin{knitrout}\scriptsize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{plot}\hldef{(mask,} \hlkwc{covariate}\hldef{=}\hlsng{"elevation"}\hldef{)}
\hlkwd{plot}\hldef{(trp,} \hlkwc{add}\hldef{=}\hlnum{TRUE}\hldef{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=0.95\linewidth]{figure/plot-mask-1} 

}


\end{knitrout}
\end{frame}




\begin{frame}[fragile]
  \frametitle{R package `secr'}
  Model density as a function of elevation. 
\begin{knitrout}\scriptsize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fm.elev} \hlkwb{<-} \hlkwd{secr.fit}\hlstd{(sch,} \hlkwc{model}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{D}\hlstd{=}\hlopt{~}\hlstd{elevation,} \hlkwc{g0}\hlstd{=}\hlopt{~}\hlnum{1}\hlstd{,} \hlkwc{sigma}\hlstd{=}\hlopt{~}\hlnum{1}\hlstd{),}
                    \hlkwc{mask}\hlstd{=mask,} \hlkwc{trace}\hlstd{=}\hlnum{FALSE}\hlstd{)}  \hlcom{## Don't use 'buffer'}
\hlkwd{coef}\hlstd{(fm.elev)}
\end{alltt}
\begin{verbatim}
##                   beta    SE.beta        lcl        ucl
## D           -0.5600286 0.23323698 -1.0171647 -0.1028925
## D.elevation  0.9419116 0.18885718  0.5717584  1.3120649
## g0          -1.1779499 0.21368740 -1.5967695 -0.7591303
## sigma        3.9089834 0.06556957  3.7804694  4.0374974
\end{verbatim}
\end{kframe}
\end{knitrout}
\pause
\vfill
Estimates on original scale (at average covariate values).
\begin{knitrout}\scriptsize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{predict}\hldef{(fm.elev)}
\end{alltt}
\begin{verbatim}
##        link  estimate SE.estimate        lcl        ucl
## D       log  1.414252   0.1967067  1.0782035  1.8550375
## g0    logit  0.235421   0.0384633  0.1684336  0.3188351
## sigma   log 49.848252   3.2720450 43.8366152 56.6843093
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{frame}



\begin{frame}[fragile]
  \frametitle{Estimated density surface}
\begin{knitrout}\scriptsize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hldef{dsurf.r} \hlkwb{<-} \hlkwd{raster}\hldef{(dsurf,} \hlkwc{covariate}\hldef{=}\hlsng{"D.0"}\hldef{)}
\hldef{pix.area} \hlkwb{<-} \hldef{(delta}\hlopt{*}\hlnum{1000}\hldef{)}\hlopt{^}\hlnum{2}
\hlkwd{plot}\hldef{(dsurf.r}\hlopt{/}\hldef{pix.area,} \hlkwc{col}\hldef{=}\hlkwd{terrain.colors}\hldef{(}\hlnum{100}\hldef{),} \hlkwc{zlim}\hldef{=}\hlkwd{c}\hldef{(}\hlnum{0}\hldef{,}\hlnum{0.18}\hldef{),}
     \hlkwc{main}\hldef{=}\hlsng{"Estimated density surface"}\hldef{)}
\end{alltt}
\end{kframe}
\end{knitrout}
\centering
\includegraphics[width=0.49\textwidth]{figure/secr-dsurf-1}
\includegraphics[width=0.49\textwidth]{figure/ippp2-1} \\
%\pause \vfill
%The units differ because we transformed to meters. \\
\end{frame}



\begin{frame}[fragile]
  \frametitle{Estimated activity centers}
  \small
  Contour map for the Empirical Bayes posterior distribution of the
  activity center for individual 1. 
\begin{knitrout}\scriptsize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{fxi.contour}\hldef{(fm.elev,} \hlkwc{i}\hldef{=}\hlnum{1}\hldef{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=0.65\linewidth]{figure/fxi-1} 

}


\end{knitrout}
\end{frame}




\begin{frame}[fragile]
  \frametitle{R package `secr'}
  We can still estimate $N$ as before. \\
  \vfill
  \inr{E.N} is the expected value of
  $N$. \inr{R.N} is the realized value of $N$. 
  \vfill
\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{region.N}\hldef{(fm.elev)}
\end{alltt}
\begin{verbatim}
##     estimate SE.estimate      lcl      ucl  n
## E.N 87.35370   12.228402 66.48162 114.7786 59
## R.N 93.53552    7.885437 81.20121 112.7224 59
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{frame}




\section{Bayes}




\begin{frame}
  \frametitle{Outline}
  \Large
  \tableofcontents[currentsection]
\end{frame}





\begin{frame}
  \frametitle{Data augmentation model}
  DA version of SCR model with inhomogeneous point process \\
  \centering
  Version 1 \\
  \begin{gather*}
    \lambda(\bs) = \exp(\beta_0 + \beta_1 \mathrm{ELEV}(\bs)) \\
    \bsi \propto \lambda(\bs) \\
    \Lambda = E(N) = \int_{\mathcal{S}} \lambda(\bs)\; \mathrm{d}\bs \\
    \psi = \Lambda/M \\
    z_i \sim \mathrm{Bern}(\psi) \\
    p_{ij} = g_0\exp(-\|\bsi-\bxj\|^2/(2\sigma^2)) \\
    y_{ijk} \sim \mathrm{Bern}(z_i\times p_{ij}) \\
    N=\sum_{i=1}^M z_i
  \end{gather*}
  \pause \vfill
  This version is relatively slow and doesn't mix that well. \\
\end{frame}





\begin{frame}[fragile]
  \frametitle{SCR with IPP -- version 1}
  \vspace{-3pt}
\begin{knitrout}\tiny
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{writeLines}\hldef{(}\hlkwd{readLines}\hldef{(}\hlsng{"SCR-elev-v1.jag"}\hldef{))}
\end{alltt}
\end{kframe}
\end{knitrout}
\begin{knitrout}\tiny
\definecolor{shadecolor}{rgb}{0.678, 0.847, 0.902}\color{fgcolor}\begin{kframe}
\begin{verbatim}
model {
beta0 ~ dnorm(0, 0.1)
beta1 ~ dnorm(0, 0.1)
g0 ~ dunif(0, 1)
sigma ~ dunif(0, 0.5)
for(g in 1:G) { ## Loop over pixels
  lambda[g] <- exp(beta0 + beta1*elevation[g])*pixelArea
  pi[g] <- lambda[g]/Lambda }
Lambda <- sum(lambda)
EN <- sum(lambda) ## Expected value of N
psi <- EN/M
for(i in 1:M) {
  s[i,1] ~ dunif(xlim[1], xlim[2]) 
  s[i,2] ~ dunif(ylim[1], ylim[2])
  pixel[i] <- lookup[round((ylim[2]-s[i,2])/delta+0.5),  ## row
                     round((s[i,1]-xlim[1])/delta+0.5)]  ## column
  logProb[i] <- log(pi[pixel[i]])
  zeros[i] ~ dpois(-logProb[i]) ## zeros trick for IPP
  z[i] ~ dbern(psi)
  for(j in 1:J) {
    dist[i,j] <- sqrt((s[i,1]-x[j,1])^2 + (s[i,2]-x[j,2])^2)
    p[i,j] <- g0*exp(-dist[i,j]^2/(2*sigma^2)) } }
for(i in 1:n) {  ## Model for observed capture histories
  for(j in 1:J) {
    y.tilde[i,j] ~ dbinom(p[i,j], K) } }
for(i in (n+1):M) { ## Model for augmented guys
  PrAtLeastOneCap[i] <- 1-prod(1-p[i,])^K
  zero.cap[i] ~ dbern(PrAtLeastOneCap[i]*z[i]) }
N <- sum(z)
}
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{frame}



% \begin{frame}
%   \frametitle{Add code to convert from secr format to 3D array}
  
% \end{frame}




\begin{frame}
  \frametitle{Data augmentation model}
  DA version of SCR model with inhomogeneous point process \\
  \centering
  Version 2 \\
  \begin{gather*}
    \tilde{\lambda}(\bs) = \exp(\beta_1 \mathrm{ELEV}(\bs)) \\
    \bsi \propto \tilde{\lambda}(\bs) \\
%    \Lambda = E(N) = \int_{\mathcal{S}} \lambda(\bs)\; \mathrm{d}\bs \\
%    \psi \sim \mathrm{Unif}(0,1) \\
    z_i \sim \mathrm{Bern}(\psi) \\
    p_{ij} = g_0\exp(-\|\bsi-\bxj\|^2/(2\sigma^2)) \\
    y_{ijk} \sim \mathrm{Bern}(z_i\times p_{ij}) \\
    N=\sum_{i=1}^M z_i
  \end{gather*}
%  \pause \vfill
  This version is faster and mixes better. \\
\end{frame}





\begin{frame}[fragile]
  \frametitle{SCR with IPP -- version 2}
\vspace{-3pt}
\begin{knitrout}\tiny
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{writeLines}\hldef{(}\hlkwd{readLines}\hldef{(}\hlsng{"SCR-elev-v2.jag"}\hldef{))}
\end{alltt}
\end{kframe}
\end{knitrout}
\begin{knitrout}\tiny
\definecolor{shadecolor}{rgb}{0.678, 0.847, 0.902}\color{fgcolor}\begin{kframe}
\begin{verbatim}
model {
psi ~ dunif(0, 1)  ## Can't put prior on psi *and* beta0
beta0 <- log(M*psi/Lambda) ## Algebra
beta1 ~ dnorm(0, 0.1)
g0 ~ dunif(0, 1)
sigma ~ dunif(0, 0.5)
for(g in 1:G) { ## Loop over pixels
  lambda[g] <- exp(beta1*elevation[g])*pixelArea
  pi[g] <- lambda[g]/Lambda }
Lambda <- sum(lambda)
EN <- M*psi
for(i in 1:M) {
  s[i,1] ~ dunif(xlim[1], xlim[2]) 
  s[i,2] ~ dunif(ylim[1], ylim[2])
  pixel[i] <- lookup[round((ylim[2]-s[i,2])/delta+0.5),  ## row
                     round((s[i,1]-xlim[1])/delta+0.5)]  ## column
  logProb[i] <- log(pi[pixel[i]])
  zeros[i] ~ dpois(-logProb[i]) ## zeros trick for IPP
  z[i] ~ dbern(psi)
  for(j in 1:J) {
    dist[i,j] <- sqrt((s[i,1]-x[j,1])^2 + (s[i,2]-x[j,2])^2)
    p[i,j] <- g0*exp(-dist[i,j]^2/(2*sigma^2))  } }
for(i in 1:n) {  ## Model for observed capture histories
  for(j in 1:J) {
    y.tilde[i,j] ~ dbinom(p[i,j], K) } }
for(i in (n+1):M) { ## Model for augmented guys
  PrAtLeastOneCap[i] <- 1-prod(1-p[i,])^K
  zero.cap[i] ~ dbern(PrAtLeastOneCap[i]*z[i])  }
N <- sum(z)
}
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{frame}



\begin{frame}
  \frametitle{SCR with IPP -- version 3}
  There's another version where we treat space as discrete, rather
  than continuous. \\
  \pause \vfill
  Under this formulation, activity centers are snapped to pixel
  centers, and a categorical prior is used instead of a continuous
  distribution. \\
  \pause \vfill
  This version is similar to what is used in likelihood-based
  methods. \\
  \pause \vfill
  It works fine, but it's slow in JAGS and it adds an extra level of
  approximation. \\
\end{frame}



\begin{frame}
  \frametitle{Inhomogeneous point process in JAGS}
  We need to do the following to use version 2:
  \begin{enumerate}
    \item Provide the spatial covariate as a vector
    \item Loop over all pixels to compute the {\it conditional}-on-$N$
      density surface. 
    \item Retain the uniform prior on the activity centers, but add a
      second probability component to force them to be distributed
      according to the density surface.
      \begin{enumerate}
        \item This requires that we create a ``lookup'' table to map
          points in space to pixel IDs
        \item Then we use the ``zero's trick'' to implement the
          non-standard probability distribution
      \end{enumerate}
    \item Put a uniform prior on $\psi$.
  \end{enumerate}
  \pause
  \vfill
  If we were using version 1, we would define $\psi=E(N)/M$ and we'd
  include $\beta_0$ in the intensity function.
\end{frame}








\begin{frame}[fragile]
  \frametitle{SCR with IPP}
  Create the lookup table
\begin{knitrout}\scriptsize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hldef{G} \hlkwb{<-} \hlkwd{nrow}\hldef{(elevation.xyz)}    \hlcom{## nPixels  }
\hldef{lookup} \hlkwb{<-} \hlkwd{matrix}\hldef{(}\hlnum{1}\hlopt{:}\hldef{G,} \hlkwc{nrow}\hldef{=}\hlkwd{nrow}\hldef{(elevation),} \hlkwc{ncol}\hldef{=}\hlkwd{ncol}\hldef{(elevation),}
                 \hlkwc{byrow}\hldef{=}\hlnum{TRUE}\hldef{)} \hlcom{## To be consistent with raster package}
\hldef{delta} \hlkwb{<-} \hlkwd{res}\hldef{(elevation)[}\hlnum{1}\hldef{]}  \hlcom{## resolution}
\hlkwd{image}\hldef{(}\hlkwd{seq}\hldef{(delta}\hlopt{/}\hlnum{2}\hldef{,} \hlnum{1}\hlopt{-}\hldef{delta}\hlopt{/}\hlnum{2}\hldef{,} \hlkwc{length}\hldef{=}\hlnum{100}\hldef{),}
      \hlkwd{seq}\hldef{(delta}\hlopt{/}\hlnum{2}\hldef{,} \hlnum{1}\hlopt{-}\hldef{delta}\hlopt{/}\hlnum{2}\hldef{,} \hlkwc{length}\hldef{=}\hlnum{100}\hldef{), lookup,} \hlkwc{asp}\hldef{=}\hlnum{1}\hldef{,}
      \hlkwc{xlab}\hldef{=}\hlsng{"x"}\hldef{,} \hlkwc{ylab}\hldef{=}\hlsng{"y"}\hldef{,} \hlkwc{frame}\hldef{=}\hlnum{FALSE}\hldef{,} \hlkwc{col}\hldef{=}\hlnum{0}\hldef{,} \hlkwc{main}\hldef{=}\hlsng{"Pixel ID"}\hldef{)}
\hlkwd{text}\hldef{(elevation.xyz}\hlopt{$}\hldef{x[}\hlkwd{seq}\hldef{(}\hlnum{5}\hldef{, G,} \hlkwc{by}\hldef{=}\hlnum{10}\hldef{)],}
     \hldef{elevation.xyz}\hlopt{$}\hldef{y[}\hlkwd{seq}\hldef{(}\hlnum{5}\hldef{, G,} \hlkwc{by}\hldef{=}\hlnum{10}\hldef{)],} \hlkwd{seq}\hldef{(}\hlnum{5}\hldef{, G,} \hlkwc{by}\hldef{=}\hlnum{10}\hldef{),} \hlkwc{cex}\hldef{=}\hlnum{0.4}\hldef{)}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{frame}


\begin{frame}
  \frametitle{Lookup table}
  \centering
  \includegraphics[width=0.8\textwidth]{figure/lookup-1}   \\
\end{frame}



\begin{frame}[fragile]
  \frametitle{SCR with IPP}
  Data
  \vspace{-6pt}
\begin{knitrout}\scriptsize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hldef{M} \hlkwb{<-} \hlnum{150}
\hldef{y.tilde} \hlkwb{<-} \hlkwd{apply}\hldef{(y,} \hlkwd{c}\hldef{(}\hlnum{1}\hldef{,}\hlnum{2}\hldef{), sum)}
\hldef{n} \hlkwb{<-} \hlkwd{nrow}\hldef{(y)}
\hldef{jags.data.SCR.elev} \hlkwb{<-} \hlkwd{list}\hldef{(}
    \hlkwc{y.tilde}\hldef{=y.tilde,} \hlkwc{n}\hldef{=n,} \hlkwc{M}\hldef{=M,} \hlkwc{J}\hldef{=J,} \hlkwc{G}\hldef{=G,} \hlkwc{delta}\hldef{=delta,}
    \hlkwc{lookup}\hldef{=lookup,} \hlkwc{pixelArea}\hldef{=delta}\hlopt{^}\hlnum{2}\hlopt{*}\hlnum{1e4}\hldef{,} \hlcom{## Convert to hectares}
    \hlkwc{elevation}\hldef{=elevation.xyz}\hlopt{$}\hldef{elevation,} \hlkwc{z}\hldef{=}\hlkwd{c}\hldef{(}\hlkwd{rep}\hldef{(}\hlnum{1}\hldef{, n),} \hlkwd{rep}\hldef{(}\hlnum{NA}\hldef{, M}\hlopt{-}\hldef{n)),}
    \hlkwc{zeros}\hldef{=}\hlkwd{rep}\hldef{(}\hlnum{0}\hldef{, M),} \hlkwc{K}\hldef{=K,} \hlkwc{zero.cap}\hldef{=}\hlkwd{rep}\hldef{(}\hlnum{0}\hldef{, M),} \hlkwc{x}\hldef{=x,} \hlkwc{xlim}\hldef{=}\hlkwd{c}\hldef{(}\hlnum{0}\hldef{,}\hlnum{1}\hldef{),} \hlkwc{ylim}\hldef{=}\hlkwd{c}\hldef{(}\hlnum{0}\hldef{,}\hlnum{1}\hldef{))}
\end{alltt}
\end{kframe}
\end{knitrout}
\pause
\vfill
  Inits and parameters
\begin{knitrout}\scriptsize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hldef{jp.SCR.elev} \hlkwb{<-} \hlkwd{c}\hldef{(}\hlsng{"beta0"}\hldef{,} \hlsng{"beta1"}\hldef{,} \hlsng{"g0"}\hldef{,} \hlsng{"sigma"}\hldef{,} \hlsng{"EN"}\hldef{,} \hlsng{"N"}\hldef{)}
\hldef{ji.SCR.elev} \hlkwb{<-} \hlkwa{function}\hldef{() \{}
    \hlkwd{list}\hldef{(}\hlkwc{z}\hldef{=}\hlkwd{c}\hldef{(}\hlkwd{rep}\hldef{(}\hlnum{NA}\hldef{, n),} \hlkwd{rep}\hldef{(}\hlnum{0}\hldef{,M}\hlopt{-}\hldef{n)),}\hlcom{#psi=runif(1),beta0=runif(1,-20,-15),}
         \hlkwc{beta1}\hldef{=}\hlnum{0.01}\hldef{,} \hlkwc{s}\hldef{=}\hlkwd{cbind}\hldef{(}\hlkwd{runif}\hldef{(M),} \hlkwd{runif}\hldef{(M)),}
         \hlkwc{g0}\hldef{=}\hlkwd{runif}\hldef{(}\hlnum{1}\hldef{),} \hlkwc{sigma}\hldef{=}\hlkwd{runif}\hldef{(}\hlnum{1}\hldef{,} \hlnum{0.05}\hldef{,} \hlnum{0.1}\hldef{)) \}}
\end{alltt}
\end{kframe}
\end{knitrout}
MCMC
  \vspace{-6pt}
\begin{knitrout}\scriptsize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(jagsUI)}
\hlstd{jags.post.SCR.elev} \hlkwb{<-} \hlkwd{jags.basic}\hlstd{(}
    \hlkwc{data}\hlstd{=jags.data.SCR.elev,} \hlkwc{inits}\hlstd{=ji.SCR.elev,}
    \hlkwc{parameters.to.save}\hlstd{=jp.SCR.elev,} \hlkwc{model.file}\hlstd{=}\hlstr{"SCR-elev-v2.jag"}\hlstd{,}
    \hlkwc{n.chains}\hlstd{=}\hlnum{3}\hlstd{,} \hlkwc{n.adapt}\hlstd{=}\hlnum{100}\hlstd{,} \hlkwc{n.iter}\hlstd{=}\hlnum{1000}\hlstd{,} \hlkwc{parallel}\hlstd{=}\hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{frame}




\begin{frame}[fragile]
  \frametitle{Posterior summaries}
\begin{knitrout}\tiny
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{summary}\hldef{(jags.post.SCR.elev)}
\end{alltt}
\begin{verbatim}
## 
## Iterations = 1:1000
## Thinning interval = 1 
## Number of chains = 3 
## Sample size per chain = 1000 
## 
## 1. Empirical mean and standard deviation for each variable,
##    plus standard error of the mean:
## 
##                Mean        SD  Naive SE Time-series SE
## EN        8.829e+01  9.977617 1.822e-01      0.4613329
## N         8.856e+01  8.166137 1.491e-01      0.4016001
## beta0    -1.415e+01  2.073910 3.786e-02      0.1500099
## beta1     8.864e-03  0.001853 3.382e-05      0.0001327
## deviance  3.177e+03 44.911679 8.200e-01      3.2062181
## g0        2.346e-01  0.039152 7.148e-04      0.0022487
## sigma     5.026e-02  0.003429 6.260e-05      0.0002202
## 
## 2. Quantiles for each variable:
## 
##                2.5%        25%        50%        75%      97.5%
## EN        6.974e+01  8.142e+01  8.800e+01   94.73555  109.06133
## N         7.500e+01  8.300e+01  8.800e+01   94.00000  107.00000
## beta0    -1.854e+01 -1.546e+01 -1.407e+01  -12.74256  -10.33929
## beta1     5.423e-03  7.608e-03  8.796e-03    0.01006    0.01278
## deviance  3.086e+03  3.148e+03  3.180e+03 3209.07695 3258.69782
## g0        1.672e-01  2.057e-01  2.310e-01    0.25895    0.32332
## sigma     4.400e-02  4.790e-02  5.005e-02    0.05247    0.05741
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{frame}



\begin{frame}[fragile]
  \frametitle{Traceplots and density plots}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{plot}\hldef{(jags.post.SCR.elev[,jp.SCR.elev[}\hlnum{1}\hlopt{:}\hlnum{3}\hldef{]])}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=0.7\textwidth]{figure/plot-mcmc-SCR-elev1-1} 

}


\end{knitrout}
\end{frame}



\begin{frame}[fragile]
  \frametitle{Traceplots and density plots}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{plot}\hldef{(jags.post.SCR.elev[,jp.SCR.elev[}\hlnum{4}\hlopt{:}\hlnum{6}\hldef{]])}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=0.7\textwidth]{figure/plot-mcmc-SCR-elev2-1} 

}


\end{knitrout}
\end{frame}




\begin{frame}[fragile]
  \frametitle{Predicted density surface in JAGS}
  Extract posterior samples of $\beta_0$ and $\beta_1$. 
\begin{knitrout}\scriptsize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hldef{beta.post} \hlkwb{<-} \hlkwd{as.matrix}\hldef{(jags.post.SCR.elev[,}\hlkwd{c}\hldef{(}\hlsng{"beta0"}\hldef{,}\hlsng{"beta1"}\hldef{)])}
\hldef{n.samples} \hlkwb{<-} \hlkwd{nrow}\hldef{(beta.post)}
\end{alltt}
\end{kframe}
\end{knitrout}
  Compute density surface for every MCMC sample
\begin{knitrout}\scriptsize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hldef{lambda.post} \hlkwb{<-} \hlkwd{matrix}\hldef{(}\hlnum{NA}\hldef{, n.pixels, n.samples)}
\hlkwa{for}\hldef{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hldef{n.samples) \{}
    \hldef{lambda.post[,i]} \hlkwb{<-} \hlkwd{exp}\hldef{(}
        \hldef{beta.post[i,}\hlsng{"beta0"}\hldef{]} \hlopt{+}
        \hldef{beta.post[i,}\hlsng{"beta1"}\hldef{]}\hlopt{*}\hldef{elevation.xyz}\hlopt{$}\hldef{elevation)}
\hldef{\}}
\hldef{lambda.post.mean} \hlkwb{<-} \hlkwd{rowMeans}\hldef{(lambda.post)}
\hldef{lambda.post.lower} \hlkwb{<-} \hlkwd{apply}\hldef{(lambda.post,} \hlnum{1}\hldef{, quantile,} \hlkwc{prob}\hldef{=}\hlnum{0.025}\hldef{)}
\hldef{lambda.post.upper} \hlkwb{<-} \hlkwd{apply}\hldef{(lambda.post,} \hlnum{1}\hldef{, quantile,} \hlkwc{prob}\hldef{=}\hlnum{0.975}\hldef{)}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{frame}




\begin{frame}[fragile]
  \frametitle{Predicted density surface}
  Make multi-panel figure showing posterior mean density surface,
  along with 95\% CI.
\begin{knitrout}\scriptsize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hldef{(latticeExtra)}
\hlkwd{trellis.par.set}\hldef{(}\hlkwc{regions}\hldef{=}\hlkwd{list}\hldef{(}\hlkwc{col}\hldef{=}\hlkwd{hcl.colors}\hldef{(}\hlnum{100}\hldef{)))} \hlcom{## Colors}
\hldef{panel1} \hlkwb{<-} \hlkwd{levelplot}\hldef{(lambda.post.lower} \hlopt{~} \hldef{x}\hlopt{+}\hldef{y, elevation.xyz,} \hlkwc{aspect}\hldef{=}\hlsng{"iso"}\hldef{,}
                    \hlkwc{at}\hldef{=}\hlkwd{seq}\hldef{(}\hlnum{0}\hldef{,}\hlnum{0.20}\hldef{,}\hlnum{0.005}\hldef{),} \hlcom{## Resolution of color key}
                    \hlkwc{colorkey}\hldef{=}\hlkwd{list}\hldef{(}\hlkwc{space}\hldef{=}\hlsng{"bottom"}\hldef{),}
                    \hlkwc{xlab}\hldef{=}\hlsng{""}\hldef{,} \hlkwc{ylab}\hldef{=}\hlsng{""}\hldef{)}
\hldef{panel2} \hlkwb{<-} \hlkwd{levelplot}\hldef{(lambda.post.mean} \hlopt{~}\hldef{x}\hlopt{+}\hldef{y, elevation.xyz,} \hlkwc{aspect}\hldef{=}\hlsng{"iso"}\hldef{,}
                    \hlkwc{at}\hldef{=}\hlkwd{seq}\hldef{(}\hlnum{0}\hldef{,}\hlnum{0.20}\hldef{,}\hlnum{0.005}\hldef{))}
\hldef{panel3} \hlkwb{<-} \hlkwd{levelplot}\hldef{(lambda.post.upper} \hlopt{~}\hldef{x}\hlopt{+}\hldef{y, elevation.xyz,} \hlkwc{aspect}\hldef{=}\hlsng{"iso"}\hldef{,}
                    \hlkwc{at}\hldef{=}\hlkwd{seq}\hldef{(}\hlnum{0}\hldef{,}\hlnum{0.20}\hldef{,}\hlnum{0.005}\hldef{))}
\hldef{panels} \hlkwb{<-} \hlkwd{c}\hldef{(panel1, panel2, panel3)}
\hldef{panels} \hlkwb{<-} \hlkwd{update}\hldef{(}
    \hldef{panels,} \hlkwc{scales}\hldef{=}\hlkwd{list}\hldef{(}\hlkwc{draw}\hldef{=}\hlnum{FALSE}\hldef{),} \hlkwc{layout}\hldef{=}\hlkwd{c}\hldef{(}\hlnum{3}\hldef{,}\hlnum{1}\hldef{),}
    \hlkwc{xlab}\hldef{=}\hlsng{""}\hldef{,} \hlkwc{ylab}\hldef{=}\hlsng{""}\hldef{,}
    \hlkwc{strip}\hldef{=}\hlkwd{strip.custom}\hldef{(}\hlkwc{bg}\hldef{=}\hlkwd{gray}\hldef{(}\hlnum{0.8}\hldef{),}
        \hlkwc{factor.levels}\hldef{=}\hlkwd{c}\hldef{(}\hlsng{"Lower CI"}\hldef{,}\hlsng{"Posterior mean"}\hldef{,}\hlsng{"Upper CI"}\hldef{)))}
\hlkwd{plot}\hldef{(panels)}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{frame}




\begin{frame}
  \frametitle{Predicted density surface}
  Posterior mean and 95\% CI \\
  \includegraphics[width=\textwidth]{figure/lambda-post-1}  \\
\end{frame}




\begin{frame}[fragile]
  \frametitle{Realized density surface}
  We need to monitor $z$ and $\bsi$.
\begin{knitrout}\scriptsize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{jags.post.SCR.elev.sz} \hlkwb{<-} \hlkwd{jags.basic}\hlstd{(}
    \hlkwc{data}\hlstd{=jags.data.SCR.elev,} \hlkwc{inits}\hlstd{=ji.SCR.elev,}
    \hlkwc{parameters.to.save}\hlstd{=}\hlkwd{c}\hlstd{(jp.SCR.elev,}\hlstr{"s"}\hlstd{,}\hlstr{"z"}\hlstd{),}
    \hlkwc{model.file}\hlstd{=}\hlstr{"SCR-elev-v2.jag"}\hlstd{,}
    \hlkwc{n.chains}\hlstd{=}\hlnum{3}\hlstd{,} \hlkwc{n.adapt}\hlstd{=}\hlnum{100}\hlstd{,} \hlkwc{n.iter}\hlstd{=}\hlnum{1000}\hlstd{,} \hlkwc{parallel}\hlstd{=}\hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}
\pause \vfill
  Extract posterior samples of $z$ and $\bsi$. 
\begin{knitrout}\scriptsize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hldef{s1.post} \hlkwb{<-} \hlkwd{as.matrix}\hldef{(jags.post.SCR.elev.sz[,}\hlkwd{paste0}\hldef{(}\hlsng{"s["}\hldef{,} \hlnum{1}\hlopt{:}\hldef{M,} \hlsng{",1]"}\hldef{)])}
\hldef{s2.post} \hlkwb{<-} \hlkwd{as.matrix}\hldef{(jags.post.SCR.elev.sz[,}\hlkwd{paste0}\hldef{(}\hlsng{"s["}\hldef{,} \hlnum{1}\hlopt{:}\hldef{M,} \hlsng{",2]"}\hldef{)])}
\hldef{z.post} \hlkwb{<-} \hlkwd{as.matrix}\hldef{(jags.post.SCR.elev.sz[,}\hlkwd{paste0}\hldef{(}\hlsng{"z["}\hldef{,} \hlnum{1}\hlopt{:}\hldef{M,} \hlsng{"]"}\hldef{)])}
\end{alltt}
\end{kframe}
\end{knitrout}
\pause \vfill
Chop activity centers into discrete intervals, then tabulate.
\begin{knitrout}\scriptsize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hldef{lambda.r.post} \hlkwb{<-} \hlkwd{array}\hldef{(}\hlnum{NA}\hldef{,} \hlkwd{c}\hldef{(}\hlkwd{sqrt}\hldef{(n.pixels),} \hlkwd{sqrt}\hldef{(n.pixels), n.samples))}
\hlkwa{for}\hldef{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hldef{n.samples) \{}
    \hldef{si1.post.d} \hlkwb{<-} \hlkwd{cut}\hldef{(s1.post[i,z.post[i,]}\hlopt{==}\hlnum{1}\hldef{],} \hlkwc{breaks}\hldef{=}\hlkwd{seq}\hldef{(}\hlnum{0}\hldef{,} \hlnum{1}\hldef{, delta))}
    \hldef{si2.post.d} \hlkwb{<-} \hlkwd{cut}\hldef{(s2.post[i,z.post[i,]}\hlopt{==}\hlnum{1}\hldef{],} \hlkwc{breaks}\hldef{=}\hlkwd{seq}\hldef{(}\hlnum{0}\hldef{,} \hlnum{1}\hldef{, delta))}
    \hldef{pixel.counts} \hlkwb{<-} \hlkwd{table}\hldef{(si2.post.d, si1.post.d)}
    \hldef{lambda.r.post[,,i]} \hlkwb{<-} \hldef{pixel.counts[}\hlkwd{sqrt}\hldef{(n.pixels)}\hlopt{:}\hlnum{1}\hldef{,]}
\hldef{\}}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{frame}



\begin{frame}[fragile]
  \frametitle{Realized density surface}
%  \begin{columns}
%  \wide    
\begin{knitrout}\scriptsize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hldef{lambda.r.mean} \hlkwb{<-} \hlkwd{raster}\hldef{(}\hlkwd{apply}\hldef{(lambda.r.post,} \hlkwd{c}\hldef{(}\hlnum{1}\hldef{,}\hlnum{2}\hldef{), mean))}
\hldef{lambda.e.mean} \hlkwb{<-} \hlkwd{raster}\hldef{(}\hlkwd{matrix}\hldef{(lambda.post.mean,} \hlkwd{sqrt}\hldef{(n.pixels),} \hlkwc{byrow}\hldef{=}\hlnum{TRUE}\hldef{))}
\hldef{lambda.re} \hlkwb{<-} \hlkwd{stack}\hldef{(lambda.r.mean, lambda.e.mean)}
\hlkwd{names}\hldef{(lambda.re)} \hlkwb{<-} \hlkwd{c}\hldef{(}\hlsng{"Realized"}\hldef{,} \hlsng{"Expected"}\hldef{)}
\hlkwd{plot}\hldef{(lambda.re,} \hlkwc{zlim}\hldef{=}\hlkwd{c}\hldef{(}\hlnum{0}\hldef{,}\hlnum{0.18}\hldef{))}
\end{alltt}
\end{kframe}
\includegraphics[width=0.99\linewidth]{figure/lambda-r-1} 
\end{knitrout}
%  \end{columns}
\end{frame}



\begin{frame}[fragile]
  \frametitle{Posterior distribution of $\bsi$}
  \small
  Posterior distribution of $\bs_1$. 
\begin{knitrout}\scriptsize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{plot}\hldef{(x,} \hlkwc{asp}\hldef{=}\hlnum{1}\hldef{,} \hlkwc{xlim}\hldef{=}\hlnum{0}\hlopt{:}\hlnum{1}\hldef{,} \hlkwc{ylim}\hldef{=}\hlnum{0}\hlopt{:}\hlnum{1}\hldef{,} \hlkwc{pch}\hldef{=}\hlnum{3}\hldef{,} \hlkwc{axes}\hldef{=}\hlnum{FALSE}\hldef{,} \hlkwc{ann}\hldef{=}\hlnum{FALSE}\hldef{)}
\hlkwd{points}\hldef{(s1.post[,}\hlnum{1}\hldef{], s2.post[,}\hlnum{1}\hldef{],} \hlkwc{pch}\hldef{=}\hlnum{16}\hldef{,} \hlkwc{col}\hldef{=}\hlkwd{rgb}\hldef{(}\hlnum{0}\hldef{,}\hlnum{0}\hldef{,}\hlnum{1}\hldef{,}\hlnum{0.1}\hldef{))}
\hlkwd{contour}\hldef{(MASS}\hlopt{::}\hlkwd{kde2d}\hldef{(s1.post[,}\hlnum{1}\hldef{], s2.post[,}\hlnum{1}\hldef{]),} \hlkwc{add}\hldef{=}\hlnum{TRUE}\hldef{)}
\hlkwd{points}\hldef{(x[y.tilde[}\hlnum{1}\hldef{,]}\hlopt{>}\hlnum{0}\hldef{,,}\hlkwc{drop}\hldef{=}\hlnum{FALSE}\hldef{],} \hlkwc{pch}\hldef{=}\hlnum{3}\hldef{,} \hlkwc{col}\hldef{=}\hlsng{"red"}\hldef{,} \hlkwc{lwd}\hldef{=}\hlnum{2}\hldef{,} \hlkwc{cex}\hldef{=}\hlnum{2}\hldef{)}
\end{alltt}
\end{kframe}
\end{knitrout}
\vspace{-1.1cm}
\centering
\includegraphics[width=0.75\textwidth]{figure/si-post-1} \\
\end{frame}



\begin{frame}[fragile]
  \frametitle{Posterior distribution of $\bsi$}
  \small
  Posterior distribution of $\bs_i$

%\vfill
\vspace{-0.5cm}
\centering
%\only<1>{\includegraphics[width=0.85\textwidth]{figure/si-post-i-2} \\}
%\only<2>{\includegraphics[width=0.85\textwidth]{figure/si-post-i-3} \\}
% \only<3>{\includegraphics[width=0.85\textwidth]{figure/si-post-i-4} \\}
\foreach \n in {1,...,30} {%
  \only<\n>{\includegraphics[width=0.85\textwidth]{figure/si-post-i-\n}\\}
}
\end{frame}




\begin{frame}[fragile]
  \frametitle{Posterior distribution of $\bsi$}
  \small
  Posterior distribution of $\bsi$ for an indiviudal \alert{not}
  captured. 
\begin{knitrout}\scriptsize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{image}\hldef{(MASS}\hlopt{::}\hlkwd{kde2d}\hldef{(s1.post[z.post[,}\hlnum{150}\hldef{]}\hlopt{==}\hlnum{1}\hldef{,}\hlnum{150}\hldef{],}
                  \hldef{s2.post[z.post[,}\hlnum{150}\hldef{]}\hlopt{==}\hlnum{1}\hldef{,}\hlnum{150}\hldef{]))}
\hlkwd{points}\hldef{(x,} \hlkwc{asp}\hldef{=}\hlnum{1}\hldef{,} \hlkwc{pch}\hldef{=}\hlnum{3}\hldef{)}
\hlcom{##points(s1.post[z.post[,150]==1,150],}
\hlcom{##       s2.post[z.post[,150]==1,150], pch=16, col=rgb(0,0,1,0.8))}
\end{alltt}
\end{kframe}
\end{knitrout}
%\vspace{-1.1cm}
\centering
\includegraphics[width=0.5\textwidth]{figure/si-post-y0-1} \\
\end{frame}





\begin{frame}
  \frametitle{Summary}
  Just as we can estimate both the realized and expected value of $N$,
  we can also estimate the realized and expected value of abundance
  (or density) at each location in the region of interest. \\
  \pause \vfill
  Sometimes, the region of interest will be different than
  $\cal S$, and we can easily obtain estimates of abundance in
  subsets of $\mathcal{S}$. \\
  \pause \vfill
  When we get back to SCR later, we'll talk about modeling both
  spatial and temporal variation in density.
\end{frame}




\section{Assignment}




\begin{frame}[fragile]
  \frametitle{Assignment}
  % Create a self-contained R script or Rmarkdown file to do the
  % following: 
  % \vfill
  % \begin{enumerate}
  %   \item Fit a ``local behavioral response'' model,
  %     rather than a ``global behavioral response'' model in secr.
  %   \item Fit a model in JAGS where $g_0$ varies among
  %     occasions. Compare estimates of $E(N)$ and $N$ to the estimates
  %     from secr for the same model (which we fit earlier).
  % \end{enumerate}
  % \vfill
  % Upload your {\tt .R} or {\tt .Rmd} file to ELC before Tuesday.
  No assignment this week. Work on your paper. \\
\end{frame}





\end{document}

