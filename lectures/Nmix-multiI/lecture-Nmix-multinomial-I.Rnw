\documentclass[color=usenames,dvipsnames]{beamer}
%\documentclass[color=usenames,dvipsnames,handout]{beamer}

\usepackage[roman]{../lectures}
%\usepackage[sans]{../lectures}


\hypersetup{pdfpagemode=UseNone,pdfstartview={FitV}}



% Load function to compile and open PDF
<<build-fun,include=FALSE,purl=FALSE>>=
source("../rnw2pdf.R")
@

% Compile and open PDF
<<buildit,include=FALSE,eval=FALSE>>=
rnw2pdf("lecture-Nmix-multinomial-I")
rnw2pdf("lecture-Nmix-multinomial-I", tangle=TRUE)
@ 


<<knitr-theme,include=FALSE,purl=FALSE>>=
##knit_theme$set("navajo-night")
knit_theme$set("edit-kwrite")
@


%% New command for inline code that isn't to be evaluated
\definecolor{inlinecolor}{rgb}{0.878, 0.918, 0.933}
\newcommand{\inr}[1]{\colorbox{inlinecolor}{\texttt{#1}}}




\begin{document}




\begin{frame}[plain]
  \LARGE
%  \maketitle
  \centering
  {\LARGE Lecture 8 -- Multinomial $N$-mixture models: \\ simulation, fitting, and prediction} \\
  {\color{default} \rule{\textwidth}{0.1pt}}
  \vfill
  \large
  WILD(FISH) 8390 \\
  Estimation of Fish and Wildlife Population Parameters \\
  \vfill
  \large
  Richard Chandler \\
  University of Georgia \\
\end{frame}






\section{Overview}



\begin{frame}[plain]
  \frametitle{Outline}
  \Large
  \only<1>{\tableofcontents}%[hideallsubsections]}
  \only<2 | handout:0>{\tableofcontents[currentsection]}%,hideallsubsections]}
\end{frame}



\begin{frame}
  \frametitle{Overview}
  The objectives are the same as with binomial $N$-mixture models. %\\
%  \pause
%  \vfill
  We want to:
  \begin{itemize}
    \item Estimate abundance
    \item Model spatial variation in abundance/density
  \end{itemize}
  \pause
  \vfill
  The difference is that, instead of repeated count data at each site,
  we have data from sampling methods such as:
  \begin{itemize}
    \item<2-> Double observer sampling
    \item<3-> Removal sampling
    \item<4-> Mark-recapture
    \item<5-> Distance sampling
    \item<6-> And others that yield multinomial counts\dots
  \end{itemize}
\end{frame}




\begin{frame}
  \frametitle{Multinomial $N$-mixture model}
  \small
  State model (with Poisson assumption)
  \begin{gather*}
    \mathrm{log}(\lambda_i) = \beta_0 + \beta_1 {\color{blue} x_{i1}} +
    \beta_2 {\color{blue} x_{i2}} + \cdots \\
    N_i \sim \mathrm{Poisson}(\lambda_i)
  \end{gather*}
  \pause
  \vfill
  Observation model
  \begin{gather*}
    \mathrm{logit}(p_{ij}) = \alpha_0 + \alpha_1 {\color{blue} x_{i1}}
    + \alpha_2 {\color{Purple} w_{ij}} + \cdots \\
    \{y_{i1}, \dots, y_{iK}\}  \sim \mathrm{Multinomial}(N_i,
    \pi(p_{i1}, \dots, p_{iJ}))
  \end{gather*}
  \pause
%  \vfill
  \small
  Definitions \\
  $\lambda_i$ -- Expected value of abundance at site $i$ \\
  $N_i$ -- Realized value of abundance at site $i$ \\
  $p_{ij}$ -- Probability of detecting \alert{an individual} at site $i$ on occasion $j$ \\
  $\pi(p)$ -- A function mapping $J$ detection probabilities to
  $K$ multinomial cell probabilities \\
  $y_{ik}$ -- Multinomial count data \\
%  \vfill
  $\color{blue} x_1$ and $\color{blue} x_2$ -- site covariates \\
%  \vspace{12pt}
  $\color{Purple} w$ -- observation covariate
\end{frame}




\begin{frame}[fragile]
  \frametitle{The multinomial distribution}
  \small
  This is the first multivariate distribution we've covered. \\
  \[
    \{y_{1}, \dots, y_{K}\}  \sim \mathrm{Multinomial}(N, \{\pi_i, \dots, \pi_K\})
  \]
  \pause
%  \vfill
  The multinomial describes how $N$ objects are distributed among
  $K$ classes (also called bins, categories, etc\dots). \\
  \pause
  \vfill
  Imagine $N=20$ animals studied for 1 year with 3 possible outcomes
  and associated probabilities: \\
  $\Pr(\mathrm{survived})=0.5$, $\Pr(\mathrm{depredated})=0.3$, $\Pr(\mathrm{starved})=0.2$. \\
  \pause
  \vfill
  Here is one possible outcome:
  \vspace{-6pt}
<<multi-sim-concept,size='footnotesize'>>=
N <- 20
pi <- c(survived=0.5, depredated=0.3, starved=0.2)
drop(rmultinom(n=1, size=N, prob=pi))
@
  \pause
  \vfill
  \centering
  Note: the probabilities must sum to 1 and the counts must sum to $N$. \\
\end{frame}



\begin{frame}[fragile]
  \frametitle{\normalsize Multinomial/Categorical vs Binomial/Bernoulli}
  \centering
  \fbox{\includegraphics[width=0.85\textwidth]{figs/fig7-1}} \\
\end{frame}



\begin{frame}
  \frametitle{Sampling methods}
  Benefits of the multinomial $N$-mixture model
  \begin{itemize}
    \item Can be applied to data from many sampling designs, simply by
      changing how the $\pi$ probabilities are computed. %\\
    \item Precision is typically better than binomial $N$-mixture
      models because there's more information in the data
  \end{itemize}
  \pause
  \vfill
  Removal sampling %\\
  \[
    {\pi(p)} = \{p, (1-p)p, (1-p)^2p, \dots, (1-p)^{K-1}p, (1-p)^K\}
  \]
  \pause %\vfill
  Double observer (\alert{independent observers})
  \[
    {\pi(p)} = \{p_1(1-p_2), (1-p_1)p_2, p_1p_2, (1-p_1)(1-p_2)\}
  \]
  \pause %\vfill
  Double observer (\alert{dependent observers})
  \[
    {\pi(p)} = \{p_1, (1-p_1)p_2, (1-p_1)(1-p_2)\}
  \]
\end{frame}












%\section{Simulation}

\section{Removal sampling}

\subsection{Likelihood-based methods}

\begin{frame}
  \frametitle{Outline}
  \Large
%  \tableofcontents[currentsection,currentsubsection]
  \tableofcontents[currentsection]
\end{frame}



\begin{frame}
  \frametitle{Removal sampling}
  \small
  Removal sampling is often used in electrofishing studies. \\
  \pause
  \vfill
  A stream section is surveyed $J$ times, fish are removed on each
  ``pass'', and the rate of removal tells us about capture
  probability.  
  \pause
  \vfill
  Definitions
  \begin{itemize}
    \setlength\itemsep{1pt}
    \item $y_{ij}$ -- number of individuals removed at site $i$ on pass $j$
    \item $p$ -- probability of catching an individual on a single pass
  \end{itemize}
  \pause \vfill
  \footnotesize
  \begin{tabular}{lc}
    \hline
    \centering
    Description                       & Multinomial cell probability \\
    \hline
    Pr(first captured on first pass)  & $\pi_1 = p$                  \\
    Pr(first captured on second pass) & $\pi_2 = (1-p)p$             \\
    Pr(first captured on third pass)  & $\pi_3 = (1-p)(1-p)p$        \\
    {\centering $\cdots$}             & $\cdots$                     \\
    Pr(first captured on pass $J$)    & $\pi_J = (1-p)^{J-1}p$       \\
    Pr(not captured)                  & $\pi_{J+1} = (1-p)^J$          \\
    \hline
  \end{tabular}
\end{frame}





<<include=FALSE,echo=FALSE>>=
set.seed(34889243)
@ 

\begin{frame}[fragile]
  \frametitle{Removal sampling, no covariates}
  \small
  Abundance
<<sim-rem-nocov1,size='scriptsize'>>=
nSites <- 100
lambda1 <- 2.6  ## Expected value of N
N1 <- rpois(n=nSites, lambda=lambda1)
@
% \item
  \pause
  \vfill
  Capture probability and \alert{all} multinomial counts
<<sim-nocov2,size='scriptsize'>>=
nPasses <- 3
K <- nPasses+1  # multinomial cells
p1 <- 0.3
pi1 <- c(p1, (1-p1)*p1, (1-p1)*(1-p1)*p1, (1-p1)^3)
y1.all <- matrix(NA, nrow=nSites, ncol=K)
for(i in 1:nSites) {
    y1.all[i,] <- rmultinom(n=1, size=N1[i], prob=pi1)    }
@
%\end{enumerate}
  \pause
  \vfill
  Discard final column of individuals not detected
<<N1y1,size='scriptsize'>>=
y1 <- y1.all[,-K]
head(y1, n=3)
@ 
\end{frame}



\begin{frame}[fragile]
  \frametitle{Removal model, covariates}
  \small
  Covariates
  \vspace{-6pt}
<<sim-cov1,size='scriptsize'>>=
streamDepth <- rnorm(nSites)
@
% \item
\vfill
  Coefficients, $\lambda$, and $p$
  \vspace{-6pt}
<<nsim-cov2,size='scriptsize'>>=
beta0 <- 1; beta1 <- 0.5
lambda2 <- exp(beta0 + beta1*streamDepth)
alpha0 <- 0; alpha1 <- -1
p2 <- plogis(alpha0 + alpha1*streamDepth)
pi2 <- t(sapply(p2, function(p) c(p, (1-p)*p, (1-p)^2*p, (1-p)^3)))
@   
% \item
\vfill
  Simulate abundance and removal data
  \vspace{-6pt}
<<sim-cov3,size='scriptsize'>>=
N2 <- rpois(nSites, lambda=lambda2)         ## local abundance 
y2.all <- matrix(NA, nrow=nSites, ncol=K)
for(i in 1:nSites) {
    y2.all[i,] <- rmultinom(n=1, size=N2[i], prob=pi2[i,])
}
y2 <- y2.all[,-K]
@   
%\end{enumerate}
\end{frame}




\begin{frame}[fragile]
  \frametitle{Simulated data}
  \begin{columns}
    \begin{column}{0.4\textwidth}
      \small
      Observations
%      \tiny
  \vspace{-6pt}
<<sim-nocov-dat,size='scriptsize'>>=
y2[1:19,]
@ 
  \end{column}
  \begin{column}{0.6\textwidth}
    \pause
%    \scriptsize
    {\centering Summary stats \\}
    \vspace{24pt}
    \small
    Proportion of sites known to be occupied
    \vspace{-6pt}
<<sim-nocov-ss1,size='scriptsize'>>=
# Max count at each site
maxCounts <- apply(y2, 1, max) 
naiveOccupancy <- sum(maxCounts>0)/nSites
naiveOccupancy 
@
  \pause
  \vfill
  \small
  Captures on each pass
  \vspace{-6pt}
<<sim-nocov-ss2,size='scriptsize'>>=
colSums(y2)
@
  Naive abundance
  \vspace{-6pt}
<<sim-nocov-ss3,size='scriptsize'>>=
sum(y2)
@
<<un,include=FALSE>>=
library(unmarked)
@ 
  \end{column}
  \end{columns}
\end{frame}









%\section{Prediction}



% \begin{frame}
%   \frametitle{Outline}
%   \Large
%   \tableofcontents[currentsection]
% \end{frame}






\begin{frame}[fragile]
  \frametitle{Prepare data in `unmarked'}
  \small
<<un-umf,size='tiny'>>=
umf <- unmarkedFrameMPois(y=y2, siteCovs=data.frame(streamDepth), type="removal")
@
\pause
<<wfac,size='scriptsize'>>=
summary(umf)
@ 
\end{frame}


% > fm <- multinomPois(~temp ~forest, umf)    

% error: Mat::operator(): index out of bounds
% terminate called after throwing an instance of 'std::logic_error'
%   what():  Mat::operator(): index out of bounds


\begin{frame}[fragile]
  \frametitle{Fit the model}
  \footnotesize
  \inr{multinomPois} has similar arguments as \inr{occu} and
  \inr{pcount}. 
<<un-fit,size='tiny'>>=
fm <- multinomPois(~streamDepth ~streamDepth, umf)    
fm
@
\pause
\vfill
Compare to actual parameter values:
\vspace{-6pt}
<<un-compare,size='tiny'>>=
c(beta0=beta0, beta1=beta1); c(alpha0=alpha0, alpha1=alpha1)
@ 
\end{frame}





\begin{frame}[fragile]
  \frametitle{\normalsize Empirical Bayes -- Site-level abundance}
<<ranef,size='scriptsize',out.width='80%',fig.align='center',fig.width=9>>=
re <- ranef(fm, K=15)
plot(re, layout=c(4,3), subset=site%in%1:12, xlim=c(-1, 11), lwd=5)
@   
\end{frame}





\begin{frame}[fragile]
  \frametitle{Total abundance (in surveyed region)}
<<Ntotal,size='scriptsize',out.width='60%',fig.align='center'>>=
N.total.post <- predict(re, func=sum, nsim=1000)
hist(N.total.post, freq=FALSE, main="", xlab="N total", ylab="Probability")
@   
\end{frame}






\begin{frame}[fragile]
  \frametitle{Prediction in `unmarked'}
  \small
  Create \texttt{data.frame} with prediction covariates. 
  \vspace{-6pt}
<<preddat,size='footnotesize'>>=
pred.data <- data.frame(streamDepth=seq(-3, 3, length=20))
@
\pause
\vfill
Get predictions of $\lambda$ for each row of prediction data.
  \vspace{-6pt}
<<predpsi,size='footnotesize'>>=
lambda.pred <- predict(fm, newdata=pred.data,
                       type='state', append=TRUE)
@
\pause
\vfill
  View $\lambda$ predictions
  \vspace{-6pt}
<<psi-head,size='footnotesize'>>=
print(head(lambda.pred), digits=2)
@
\end{frame}





\begin{frame}[fragile]
  \frametitle{Prediction in `unmarked'}
<<pred-lam2,fig.width=7,fig.height=5,size='tiny',out.width='80%',fig.align='center',echo=-1>>=
par(mai=c(0.9,0.9,0.1,0.1))
plot(Predicted ~ streamDepth, lambda.pred, ylab="Expected value of abundance",
     ylim=c(0,30), xlab="Stream depth", type="l")
lines(lower ~ streamDepth, lambda.pred, col="grey")
lines(upper ~ streamDepth, lambda.pred, col="grey")
points(rowSums(y2)~streamDepth)
lines(lowess(rowSums(y2)~streamDepth), col="blue")  ## Loess line for fun (it's way off)
@   
\end{frame}







\begin{frame}[fragile]
  \frametitle{In-class exercise}
  % \small
  % \begin{enumerate}
  %   \item Predict
  %   \end{enumerate}
  %   \centering
%  \large
  Do the following using the fitted removal model above:
  \begin{enumerate}
    \normalsize
    \item Predict $p$ when \verb+streamDepth=-1+
    \item Compute $\pi_1, \pi_2, \pi_3, \pi_4$
  \end{enumerate}
\end{frame}


\subsection{Bayesian methods}


\begin{frame}
  \frametitle{Outline}
  \Large
  \tableofcontents[currentsection,currentsubsection]
\end{frame}


\begin{frame}
  \frametitle{Bayesian multinomial $N$-mixture models}
  There are several equivalent formulations of the multinomial that we
  can exploit to fit the model in JAGS.
  \begin{itemize}
    \item Conditional-on-$N$, missing $y_{iK}$
    \item Conditional-on-$N$, conditional on $n_i=\sum_{k=1}^{K-1} y_{i,k}$
    \item Conditional-on-$N$, sequential binomial
    \item Marginalized $N$
  \end{itemize}
  
\end{frame}




\begin{frame}[fragile]
  \frametitle{Conditional-on-$N$, missing $y_k$}
\end{frame}





\begin{frame}[fragile]
  \frametitle{Conditional-on-$N$, missing $y_k$}
  \footnotesize
  Under this formulation, we view the final multinomial cell
  (corresponding to individuals not detected) as missing data. \\
  \pause
  Unfortunately, this won't work in JAGS because it doesn't allow
  missing values in multinomial outcomes.
  \pause
<<bugs-removal1,size='tiny',echo=FALSE>>=
writeLines(readLines("removal-mod1.jag"))
@
<<jagsUI,include=FALSE>>=
library(jagsUI)
@ 
\end{frame}





\begin{frame}[fragile]
  \frametitle{\normalsize Conditional-on-$N$ and $n_i=\sum_{k=1}^{K-1} y_{i,k}$}
  Rather than treating the final multinomial cell as missing data:
  \[
    \{y_{i,1}, \dots, y_{i,K-1}, \mathtt{NA}\} \sim
    \mathrm{Multinomial}(N_i, \{\pi_{i,1}, \dots, \pi_{i,K-1}, \pi_{i,K}\})
  \]
  \pause
  \vfill
  We can break the problem down into two steps by conditioning on
  $n_i$, the number captured:
  \small
  \begin{gather*}
    n_i \sim \mathrm{Bin}(N_i, 1-\pi_K) \\
    \{y_{i,1}, \dots, y_{i,K-1}\} \sim \mathrm{Multinomial}(n_i,
    \{\pi_{i,1}, \dots, \pi_{i,K-1}\}/(1-\pi_K))
  \end{gather*}
\end{frame}



\begin{frame}[fragile]
  \frametitle{\normalsize Conditional-on-$N$ and $n_i=\sum_{k=1}^{K-1} y_{i,k}$}
<<bugs-removal2,size='scriptsize',echo=FALSE>>=
writeLines(readLines("removal-mod2.jag"))
@
\end{frame}





\begin{frame}[fragile]
  \frametitle{Data, inits, and parameters}
  Put data in a named list
  \vspace{-12pt}
<<bugs-data2,size='small'>>=
jags.data.rem2 <- list(y=y2, n=rowSums(y2),
                       streamDepth=streamDepth,
                       nSites=nSites, nPasses=nPasses)
@
\pause
\vfill
  Initial values
  \vspace{-12pt}
<<bugs-inits,size='small'>>=
jags.inits.rem <- function() {
    list(lambda.intercept=runif(1), alpha0=rnorm(1),
         N=rowSums(y2)+1)
}
@ 
\pause
\vfill
  Parameters to monitor
  \vspace{-12pt}
<<bugs-pars,size='small'>>=
jags.pars.rem <- c("beta0", "beta1",
                   "alpha0", "alpha1", "totalAbundance")
@ 
\end{frame}





\begin{frame}[fragile]
  \frametitle{MCMC}
  \small
<<bugs-mcmc-rem2,size='scriptsize',message=FALSE,cache=FALSE,results='hide'>>=
library(jagsUI)
jags.post.rem2 <- jags.basic(data=jags.data.rem2, inits=jags.inits.rem,
                             parameters.to.save=jags.pars.rem,
                             model.file="removal-mod2.jag",
                             n.chains=3, n.adapt=100, n.burnin=0,
                             n.iter=2000, parallel=TRUE)
@ 
\end{frame}



\begin{frame}[fragile]
  \frametitle{Summarize output}
<<bugs-sum-rem2,size='tiny'>>=
summary(jags.post.rem2[,jags.pars.rem])
@ 
\end{frame}




\begin{frame}[fragile]
  \frametitle{Traceplots and density plots}
<<bugs-plot1-rem2,size='footnotesize',out.width="0.7\\textwidth",fig.align='center'>>=
plot(jags.post.rem2[,jags.pars.rem[1:3]])
@ 
\end{frame}



\begin{frame}[fragile]
  \frametitle{Traceplots and density plots}
<<bugs-plot2-rem2,size='footnotesize',out.width="0.7\\textwidth",fig.align='center'>>=
plot(jags.post.rem2[,jags.pars.rem[4:5]])
@ 
\end{frame}




\begin{frame}[fragile]
  \frametitle{\normalsize Conditional-on-$N$, sequential binomial}
<<bugs-removal3,size='scriptsize',echo=FALSE>>=
writeLines(readLines("removal-mod3.jag"))
@
\end{frame}





\begin{frame}[fragile]
  \frametitle{Data, inits, and parameters}
  Put data in a named list
  \vspace{-12pt}
<<bugs-data3,size='small'>>=
jags.data.rem3 <- list(y=y2, streamDepth=streamDepth,
                       nSites=nSites)
@
\vfill
  Do MCMC
<<bugs-mcmc-rem3,size='scriptsize',message=FALSE,cache=FALSE,results='hide'>>=
jags.post.rem3 <- jags.basic(data=jags.data.rem3, inits=jags.inits.rem,
                             parameters.to.save=jags.pars.rem,
                             model.file="removal-mod3.jag",
                             n.chains=3, n.adapt=100, n.burnin=0,
                             n.iter=2000, parallel=TRUE)
@ 
\end{frame}





\begin{frame}[fragile]
  \frametitle{Summarize output}
<<bugs-sum-rem3,size='tiny'>>=
summary(jags.post.rem3[,jags.pars.rem])
@ 
\end{frame}




\begin{frame}[fragile]
  \frametitle{Traceplots and density plots}
<<bugs-plot1-rem3,size='footnotesize',out.width="0.7\\textwidth",fig.align='center'>>=
plot(jags.post.rem3[,jags.pars.rem[1:3]])
@ 
\end{frame}



\begin{frame}[fragile]
  \frametitle{Traceplots and density plots}
<<bugs-plot2-rem3,size='footnotesize',out.width="0.7\\textwidth",fig.align='center'>>=
plot(jags.post.rem3[,jags.pars.rem[4:5]])
@ 
\end{frame}







\begin{frame}[fragile]
  \frametitle{Marginalized $N$}
<<bugs-removal4,size='scriptsize',echo=FALSE>>=
writeLines(readLines("removal-mod4.jag"))
@
\end{frame}





\begin{frame}[fragile]
  \frametitle{Data, inits, and parameters}
  Put data in a named list
  \vspace{-12pt}
<<bugs-data4,size='small'>>=
jags.data.rem4 <- list(y=y2, streamDepth=streamDepth,
                       nSites=nSites)
@
\vfill
  Do MCMC
<<bugs-mcmc-rem4,size='scriptsize',message=FALSE,cache=FALSE,results='hide'>>=
jags.post.rem4 <- jags.basic(data=jags.data.rem4, inits=jags.inits.rem,
                             parameters.to.save=jags.pars.rem,
                             model.file="removal-mod4.jag",
                             n.chains=3, n.adapt=100, n.burnin=0,
                             n.iter=2000, parallel=TRUE)
@ 
\end{frame}





\begin{frame}[fragile]
  \frametitle{Summarize output}
<<bugs-sum-rem4,size='tiny'>>=
summary(jags.post.rem4[,jags.pars.rem[1:4]])
@ 
\end{frame}




\begin{frame}[fragile]
  \frametitle{Traceplots and density plots}
<<bugs-plot1-rem4,size='footnotesize',out.width="0.7\\textwidth",fig.align='center'>>=
plot(jags.post.rem3[,jags.pars.rem[1:4]])
@ 
\end{frame}





\section{Double observer sampling}

\begin{frame}
  \frametitle{Outline}
  \Large
  \tableofcontents[currentsection,currentsubsection]
\end{frame}




\begin{frame}
  \frametitle{Double observer sampling (independent)}
  \small
  Two observers sample together, working independently. \\
  \pause
  \vfill
  After each survey, they compare notes and figure out which
  individual were detected by observer A only, B only, or by both. \\
  \pause
  \vfill
  Definitions
  \begin{itemize}
    \setlength\itemsep{1pt}
    \item $y_{i1}$ -- number of individuals detected only by observer A
    \item $y_{i2}$ -- number of individuals detected only by observer B
    \item $y_{i3}$ -- number of individuals detected by observers A and B
    \item $p_1$ -- probability that observer A detects an individual 
    \item $p_2$ -- probability that observer B detects an individual 
  \end{itemize}
  \pause \vfill
  \footnotesize
  \begin{tabular}{lc}
    \hline
    \centering
    Description & Multinomial cell probability \\
    \hline
    Pr(detected by observer A but not B) & $\pi_1 = p_1(1-p_2)$ \\
    Pr(detected by observer B but not A) & $\pi_2 = (1-p_1)p_2$ \\
    Pr(detected by observers A and B) & $\pi_3 = p_1p_2$ \\
    Pr(not detected) & $\pi_4 = (1-p_1)(1-p_2)$ \\
    \hline
  \end{tabular}
\end{frame}





\begin{frame}
  \frametitle{Double observer sampling (dependent)}
  \small
  Two observers sample at the same time, but observer B only records
  what observer A missed. \\
  \pause
  \vfill
  Often used in aerial waterfowl surveys with two pilots. \\
  \pause
  \vfill
  Definitions
  \begin{itemize}
    \setlength\itemsep{1pt}
    \item $y_{i1}$ -- number of individuals detected by observer A
    \item $y_{i2}$ -- number of individuals missed by A but
      detected by B
    \item $p_1$ -- probability that observer A detects an individual 
    \item $p_2$ -- probability that observer B detects an individual 
  \end{itemize}
  \pause \vfill
  \footnotesize
  \begin{tabular}{lc}
    \hline
    \centering
    Description & Multinomial cell probability \\
    \hline
    Pr(detected by observer A) & $\pi_1 = p_1$ \\
    Pr(detected by observer B but not A) & $\pi_2 = (1-p_1)p_2$ \\
    Pr(not detected) & $\pi_3 = (1-p_1)(1-p_2)$ \\
    \hline
  \end{tabular}
\end{frame}

\subsection{Likelihood-based methods}


\subsection{Bayesian methods}



\begin{frame}[plain]
  \frametitle{Outline}
  \Large
  \tableofcontents[currentsection,currentsubsection]
\end{frame}







% \begin{frame}[fragile]
%   \frametitle{Data, inits, and parameters}
%   Put data in a named list
%   \vspace{-12pt}
% <<bugs-data,size='small'>>=
% jags.data <- list(y=y2, temp=temp,
%                   forestMixed=forestMixed,
%                   forestPine=forestPine,
%                   nSites=nSites, nOccasions=nVisits)
% @
% \pause
% \vfill
%   Initial values
%   \vspace{-12pt}
% <<bugs-inits,size='small'>>=
% jags.inits <- function() {
%     list(beta0=rnorm(1), alpha0=rnorm(1), N=maxCounts)
% }
% @ 
% \pause
% \vfill
%   Parameters to monitor
%   \vspace{-12pt}
% <<bugs-pars,size='small'>>=
% jags.pars <- c("beta0", "beta1", "beta2",
%                "alpha0", "alpha1", "totalAbundance")
% @ 
% \end{frame}





% \begin{frame}[fragile]
%   \frametitle{MCMC}
%   \small
% <<bugs-mcmc,size='scriptsize',message=FALSE,cache=TRUE>>=
% library(jagsUI)
% jags.post.samples <- jags.basic(data=jags.data, inits=jags.inits,
%                                 parameters.to.save=c(jags.pars, "N"), ## NOTE "N"!
%                                 model.file="Nmix-model-covs.jag",
%                                 n.chains=3, n.adapt=100, n.burnin=0,
%                                 n.iter=2000, parallel=TRUE)
% @ 
% \end{frame}



% \begin{frame}[fragile]
%   \frametitle{Summarize output}
% <<bugs-sum,size='tiny'>>=
% summary(jags.post.samples[,jags.pars])
% @ 
% \end{frame}


% \begin{frame}[fragile]
%   \frametitle{Local abundance}
% <<localN,out.width='70%',fig.align='center',size='scriptsize'>>=
% plot(jags.post.samples[,paste0("N[", 1:4, "]")])
% @   
% \end{frame}



% \begin{frame}[fragile]
%   \frametitle{Traceplots and density plots}
% <<bugs-plot1,size='footnotesize',out.width="0.7\\textwidth",fig.align='center'>>=
% plot(jags.post.samples[,jags.pars[1:3]])
% @ 
% \end{frame}



% \begin{frame}[fragile]
%   \frametitle{Traceplots and density plots}
% <<bugs-plot2,size='footnotesize',out.width="0.7\\textwidth",fig.align='center'>>=
% plot(jags.post.samples[,jags.pars[4:5]])
% @ 
% \end{frame}




% \begin{frame}[fragile]
%   \frametitle{Bayesian prediction}
%   \small
%   First, extract the $p$ coefficients
%   \vspace{-6pt}
% <<psi-coefs,size='scriptsize'>>=
% p.coef.post <- as.matrix(jags.post.samples[,c("alpha0","alpha1")])
% head(p.coef.post, n=4)
% @
%   \pause
%   \vfill
%   Create prediction matrix, one row for each MCMC iteration.
%   \vspace{-6pt}
% %  Columns represent covariate values. 
% <<p-predmat,size='scriptsize'>>=
% n.iter <- nrow(p.coef.post)
% temp.pred <- seq(-3, 3, length=50)
% p.post.pred <- matrix(NA, nrow=n.iter, ncol=length(temp.pred))
% @   
%   \pause
%   \vfill
%   Predict $p$ for each MCMC iteration.
%   \vspace{-6pt}
% %  using covariate values from \inr{pred.data}. 
% <<psi-pred-bayes,size='scriptsize'>>=
% for(i in 1:n.iter) {
%     p.post.pred[i,] <- plogis(p.coef.post[i,"alpha0"] +
%                               p.coef.post[i,"alpha1"]*temp.pred)
% }
% @ 
% \end{frame}





% \begin{frame}[fragile]
%   \frametitle{Bayesian prediction}
% %  Now with posterior mean and 95\% CI
% <<psi-pred-post-meanCI,size='tiny',fig.align='center',out.width='70%',fig.height=5,echo=-(1),dev='png',cache=TRUE,dpi=200>>=
% par(mai=c(0.9,0.9,0.1,0.1))  
% plot(temp.pred, p.post.pred[1,], type="l", xlab="Temperature (standardized)",
%      ylab="Detection probability", ylim=c(0, 1), col=gray(0.8))
% for(i in seq(1, n.iter, by=10)) {  ## Thin by 10
%     lines(temp.pred, p.post.pred[i,], col=gray(0.8))  }
% pred.post.mean <- colMeans(p.post.pred)
% pred.post.lower <- apply(p.post.pred, 2, quantile, prob=0.025)
% pred.post.upper <- apply(p.post.pred, 2, quantile, prob=0.975)
% lines(temp.pred, pred.post.mean, col="blue")
% lines(temp.pred, pred.post.lower, col="blue", lty=2)
% lines(temp.pred, pred.post.upper, col="blue", lty=2)
% @ 
% \end{frame}







\begin{frame}[plain]
  \frametitle{Outline}
  \Large
  \tableofcontents[currentsection,currentsubsection]
\end{frame}











% \begin{frame}[fragile]
%   \frametitle{Prior prediction}
%   \small
%   Push the prior samples through the model to predict $p$
% <<psi-coefs-prior,size='scriptsize'>>=
% p.coef.prior <- as.matrix(jags.prior.samples[,c("alpha0","alpha1")])
% p.prior.pred <- matrix(NA, nrow=n.iter, ncol=length(temp.pred))
% for(i in 1:n.iter) {
%     p.prior.pred[i,] <- plogis(p.coef.prior[i,"alpha0"] +
%                                p.coef.prior[i,"alpha1"]*temp.pred)
% }
% @ 
% \end{frame}





% \begin{frame}[fragile]
%   \frametitle{Bayesian prediction}
%   Compute prior mean and 95\% CI for $p$ predictions
% <<prior-post-pred-1,size='scriptsize'>>=
% pred.prior.mean <- colMeans(p.prior.pred)
% pred.prior.lower <- apply(p.prior.pred, 2, quantile, prob=0.025)
% pred.prior.upper <- apply(p.prior.pred, 2, quantile, prob=0.975)
% @
%   \pause
%   \vfill
%   Show credible regions using shaded polygons. Include a few prior prediction lines.
% <<prior-post-pred-2,size='scriptsize',fig.height=6,dev='png',dpi=200,fig.show='hide'>>=
% plot(temp.pred, p.post.pred[1,], type="n", xlab="Temperature (standardized)",
%      ylab="Detection probability", ylim=c(0, 1.3), col=gray(0.8))
% polygon(x=c(temp.pred, rev(temp.pred)),
%         y=c(pred.post.lower, rev(pred.post.upper)),
%         col=rgb(0,0,1,0.5), border=NA)                   # Post CI
% polygon(x=c(temp.pred, rev(temp.pred)),
%         y=c(pred.prior.lower, rev(pred.prior.upper)),
%         col=rgb(0,1,0,0.5), border=NA)                   # Prior CI
% for(i in seq(1, n.iter, by=100)) {  ## Thin by 100
%     lines(temp.pred, p.prior.pred[i,], col=gray(0.8))  } # Prior preds
% lines(temp.pred, pred.post.mean, col="blue", lwd=2)
% lines(temp.pred, pred.prior.mean, col="darkgreen", lwd=2)
% legend(-3, 1.3, c("Prior mean", "Prior samples", "Posterior mean"),
%        col=c("darkgreen", "grey", "blue"), lwd=2)
% @ 
% \end{frame}



% \begin{frame}
%   \frametitle{Prior and posterior prediction}
%   \vspace{-3pt}
%   \centering
%   \includegraphics[width=0.9\textwidth]{figure/prior-post-pred-2-1}  \\
% \end{frame}



% \begin{frame}
%   \frametitle{Prior predictive recap}
%   There are two common strategies for specifying priors:
%   \begin{enumerate}
%     \item Use uniform/flat priors to obtain results that will often be
%       similar to likelihood-based methods.
%     \item Use priors that reflect available information.
%   \end{enumerate}
%   \pause
%   \vfill
%   The second approach can be used even if there isn't much prior
%   information available. Priors can allow for the
%   possibility of being ``surprised'' by the data, but without
%   putting most of the prior weight on extreme values. \\
%   \pause
%   \vfill
%   Often, highly diffuse priors on the link scales result in most of the
%   prior weight being on extreme values on the natural scales. \\
%   \pause
%   \vfill
%   Prior predictive checks can be used to assess this possibility, and
%   should be a standard component of Bayesian analysis. \\
% \end{frame}



\section{Assignment}




\begin{frame}[fragile]
  \frametitle{Assignment}
  % \small
  \footnotesize
  Create a self-contained R script or Rmarkdown file
  to do the following:
  \vfill
  \begin{enumerate}
%    \small
    \footnotesize
    \item Using the simulated data, compare the prior and posterior
      predictive distributions of $\lambda$ for each of the 3 forest
      types. 
    \item Change the priors for $\alpha_0$ and $\alpha_1$ from
      \inr{dnorm(0,0.5)} to \inr{dnorm(0, 0.001)} and then compare the
      prior and posterior predictions of $p$ as a function of
      temperature. Make the same graph as we made above. How
      sensitive is the posterior to the prior?
    \item Fit a binomial $N$-mixture model to the Canada warbler data
      using `unmarked'. The data include: 
      \begin{itemize}
        \footnotesize
        \item Response: \texttt{cawa1, cawa2, cawa3, cawa4}
        \item Site covs: \texttt{Elevation, Wind, Noise}
      \end{itemize}
    \item Graph the predictions of $\lambda$ over the 
      elevation range, along with 95\% CIs.
  \end{enumerate}
  \vfill
  Upload your {\tt .R} or {\tt .Rmd} file to ELC before Monday. 
\end{frame}





\end{document}

