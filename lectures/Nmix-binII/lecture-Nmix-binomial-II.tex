\documentclass[color=usenames,dvipsnames]{beamer}
%\documentclass[color=usenames,dvipsnames,handout]{beamer}

\usepackage[roman]{../lectures}
%\usepackage[sans]{../lectures}

\usepackage{booktabs}
%\usepackage{lipsum}

\hypersetup{pdfpagemode=UseNone,pdfstartview={FitV}}



% Load function to compile and open PDF


% Compile and open PDF






%% New command for inline code that isn't to be evaluated
\definecolor{inlinecolor}{rgb}{0.878, 0.918, 0.933}
\newcommand{\inr}[1]{\colorbox{inlinecolor}{\texttt{#1}}}


% \newcommand\blfootnote[1]{%
%   \begingroup
%   \renewcommand\thefootnote{}\footnote{#1}%
%   \addtocounter{footnote}{-1}%
%   \endgroup
% }


\begin{document}




\begin{frame}[plain]
  \LARGE
%  \maketitle
  \centering
  {\LARGE Lecture 7 -- Binomial $N$-mixture models: \\
    model selection, spatial prediction, and goodness-of-fit} \\  
  {\color{default} \rule{\textwidth}{0.1pt}}
  \vfill
  \large
  WILD(FISH) 8390 \\
  Estimation of Fish and Wildlife Population Parameters \\
  \vfill
  \large
  Richard Chandler \\
  University of Georgia \\
\end{frame}





\section{Model selection}



\begin{frame}[plain]
  \frametitle{Outline}
  \Large
  \only<1>{\tableofcontents}%[hideallsubsections]}
%  \only<2 | handout:0>{\tableofcontents[currentsection,currentsubsection]}
\end{frame}





\begin{frame}
  \frametitle{Model selection}
  In scientific contexts, we want models that describe natural
  processes and allow us to evaluate hypotheses. \\
  \pause
  \vfill
  Models should be predictive, but they shouldn't be crafted with the
  sole goal of prediction in mind. \\
  \pause
  \vfill
  Scientists typically don't care about prediction if the model
  doesn't help us learn about the processes that gave rise to the
  data. \\  
  \pause
  \vfill
  Nonetheless, predictive performance is often the best way
  to compare models and avoid underfitting and overfitting. \\
  \pause
  \vfill
  Just make sure the models being compared were motivated by clear
  hypotheses.
\end{frame}




\begin{frame}
  \frametitle{Model selection}
  Prediction accuracy increases with model complexity up to a point,
  until overfitting kicks in. \\
  \pause
  \vfill
  The best way to determine if a model is too simplistic or too
  complex is to compare predictions to new observations. \\
  \pause
  \vfill
  However, we rarely have the resources to
  collect additional data for the sake of evaluating predictive
  performance. \\ 
  % \pause
  % \vfill
  % Trouble is, people rarely collect new observations. \\
  \pause
  \vfill
  A cheaper (albeit less desirable) alternative is to use
  cross-validation: 
  \begin{itemize}
    \item Split data into K partitions
    \item Fit model to the `in-sample' K-1 partitions
    \item Predict the holdout `out-of-sample' partition
  \end{itemize}
  \pause
  \vfill
  Information criteria like AIC and WAIC yield similar predictive
  rankings as cross-validation, but with less computation.    
\end{frame}



\subsection{Likelihood-based methods}



\begin{frame}
  \frametitle{Outline}
  \Large
  \tableofcontents[currentsection,currentsubsection]
\end{frame}





\begin{frame}
  \frametitle{Model selection with AIC}
  \small
  Most information criteria (IC) take on a form like this:
  \[
     \mathrm{IC} = \mathrm{fit} + \mathrm{penalty}
  \]
  where `fit' describes the \alert{in-sample} predictive accuracy and 
  `penalty' describes model complexity. \\
  \pause
  \vfill
  In the case of Akaike's `An Information Criterion', which
  approximates leave-one-out cross validation, `fit' is described by
  the likelihood and the `penalty' is determined by the number of parameters:
  \[
%     \mathrm{AIC} = -2\times \mathrm{logLikelihood} + 2\times \mathrm{nParameters}
     \mathrm{AIC} = -2 \log(L) + 2P 
   \]
   where $L$ is the likelihood evaluated at the MLE and $P$ is
   the number of parameters. \\
   \pause
   \vfill
   The lower the AIC, the better the \alert{out-of-sample} predictive
   performance.
\end{frame}




\bgroup
\let\oldfootnoterule\footnoterule
\def\footnoterule{\only<1->\oldfootnoterule}
\begin{frame}
  \frametitle{Model selection with AIC}
%  \small
  For an $N$-mixture model, the `integrated likelihood' is computed by
  marginalizing (summing over all possible values of) $N_i$:
  \[
     L = \prod_{i=1}^M \sum_{N^*_i=\max(y_i)}^{K\approx \infty}
     \left\{\prod_{j=1}^J p(y_{ij}|N^*_i,p)\right\}p(N^*_i|\lambda)
  \]
%  \pause
  where $p(y_{ij}|N_i,p)$ is the binomial probability
  density\footnote<1->{\scriptsize For discrete random variables, 
    ``mass'' is often used instead of ``density''.} function 
  (pdf), and $p(N_i|\lambda)$ is the Poisson (or similar) pdf for
  local abundance. 
\end{frame}
\egroup





\bgroup
\let\oldfootnoterule\footnoterule
\def\footnoterule{\only<2->\oldfootnoterule}
\begin{frame}[fragile]
  \frametitle{Model selection in `unmarked'}
  \small
  Import the grouse data
  \vspace{-6pt}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(unmarked)}
\hlstd{grouse.data} \hlkwb{<-} \hlkwd{read.csv}\hlstd{(}\hlstr{"grouse_data_Nmix.csv"}\hlstd{,} \hlkwc{row.names}\hlstd{=}\hlnum{1}\hlstd{)}
\hlstd{grouse.umf} \hlkwb{<-} \hlkwd{unmarkedFramePCount}\hlstd{(}
    \hlkwc{y}\hlstd{=grouse.data[,}\hlkwd{paste0}\hlstd{(}\hlstr{"grouse"}\hlstd{,}\hlnum{1}\hlopt{:}\hlnum{3}\hlstd{)],}
    \hlkwc{siteCovs}\hlstd{=grouse.data[,}\hlkwd{c}\hlstd{(}\hlstr{"utmE"}\hlstd{,}\hlstr{"utmN"}\hlstd{,}\hlstr{"elevation"}\hlstd{)],}
    \hlkwc{obsCovs}\hlstd{=}\hlkwd{list}\hlstd{(}\hlkwc{temp}\hlstd{=grouse.data[,}\hlkwd{paste0}\hlstd{(}\hlstr{"Temperature."}\hlstd{,}\hlnum{1}\hlopt{:}\hlnum{3}\hlstd{)]))}
\end{alltt}
\end{kframe}
\end{knitrout}
\pause
\vfill
Standardize the covariates\footnote<2->{\inr{scale} will only work if all the covariates are continuous}:
  \vspace{-6pt}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{site.covs.s} \hlkwb{<-} \hlkwd{scale}\hlstd{(}\hlkwd{siteCovs}\hlstd{(grouse.umf))}
\hlkwd{colnames}\hlstd{(site.covs.s)} \hlkwb{<-} \hlkwd{paste0}\hlstd{(}\hlkwd{colnames}\hlstd{(site.covs.s),} \hlstr{".s"}\hlstd{)}
\hlkwd{siteCovs}\hlstd{(grouse.umf)} \hlkwb{<-} \hlkwd{cbind}\hlstd{(}\hlkwd{siteCovs}\hlstd{(grouse.umf), site.covs.s)}
\hlkwd{obsCovs}\hlstd{(grouse.umf)} \hlkwb{<-} \hlkwd{scale}\hlstd{(}\hlkwd{obsCovs}\hlstd{(grouse.umf))}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{frame}
\egroup




\begin{frame}[fragile]
  \frametitle{Model selection in `unmarked'}
  \small
  Fit some models
  \vspace{-6pt}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fm1} \hlkwb{<-} \hlkwd{pcount}\hlstd{(}\hlopt{~}\hlstd{temp} \hlopt{~} \hlstd{elevation.s}\hlopt{+}\hlstd{utmE.s}\hlopt{+}\hlstd{utmN.s, grouse.umf,} \hlkwc{K}\hlstd{=}\hlnum{50}\hlstd{)}
\hlstd{fm2} \hlkwb{<-} \hlkwd{pcount}\hlstd{(}\hlopt{~}\hlstd{temp} \hlopt{~} \hlstd{elevation.s}\hlopt{+}\hlstd{utmN.s, grouse.umf,} \hlkwc{K}\hlstd{=}\hlnum{50}\hlstd{)}
\hlstd{fm3} \hlkwb{<-} \hlkwd{pcount}\hlstd{(}\hlopt{~}\hlstd{temp} \hlopt{~} \hlstd{elevation.s, grouse.umf,} \hlkwc{K}\hlstd{=}\hlnum{50}\hlstd{)}
\hlstd{fm4} \hlkwb{<-} \hlkwd{pcount}\hlstd{(}\hlopt{~}\hlnum{1} \hlopt{~} \hlstd{elevation.s}\hlopt{+}\hlstd{utmN.s, grouse.umf,} \hlkwc{K}\hlstd{=}\hlnum{50}\hlstd{)}
\hlstd{fm5} \hlkwb{<-} \hlkwd{pcount}\hlstd{(}\hlopt{~}\hlnum{1} \hlopt{~} \hlstd{elevation.s, grouse.umf,} \hlkwc{K}\hlstd{=}\hlnum{50}\hlstd{)}
\hlstd{fm6} \hlkwb{<-} \hlkwd{pcount}\hlstd{(}\hlopt{~}\hlnum{1} \hlopt{~} \hlnum{1}\hlstd{, grouse.umf,} \hlkwc{K}\hlstd{=}\hlnum{50}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}
\pause
\vfill
Put models in a special type of list
  \vspace{-6pt}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{grouse.models} \hlkwb{<-} \hlkwd{fitList}\hlstd{(}\hlstr{'lam(elev+utmE+utmN)p(temp)'}\hlstd{=fm1,}
                         \hlstr{'lam(elev+utmN)p(temp)'}\hlstd{=fm2,}
                         \hlstr{'lam(elev)p(ptemp)'}\hlstd{=fm3,}
                         \hlstr{'lam(elev+utmN)p(.)'}\hlstd{=fm4,}
                         \hlstr{'lam(elev)p(.)'}\hlstd{=fm5,}
                         \hlstr{'lam(.)p(.)'}\hlstd{=fm6)}
\end{alltt}


{\ttfamily\noindent\bfseries\color{errorcolor}{\#\# Error in fitList(`lam(elev+utmE+utmN)p(temp)` = fm1, `lam(elev+utmN)p(temp)` = fm2, : could not find function "{}fitList"{}}}\end{kframe}
\end{knitrout}
\pause
Uh oh, missing values differ among models.
\end{frame}



\begin{frame}[fragile]
  \frametitle{Model selection in `unmarked'}
  \small
  Replace count data with \inr{NA} where associated covariates are missing:
  \vspace{-6pt}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{na.sites} \hlkwb{<-} \hlkwd{apply}\hlstd{(}\hlkwd{is.na}\hlstd{(site.covs.s),} \hlnum{1}\hlstd{, any)}
\hlstd{grouse.counts} \hlkwb{<-} \hlkwd{getY}\hlstd{(grouse.umf)}
\end{alltt}


{\ttfamily\noindent\bfseries\color{errorcolor}{\#\# Error in getY(grouse.umf): could not find function "{}getY"{}}}\begin{alltt}
\hlstd{grouse.counts[na.sites,]} \hlkwb{<-} \hlnum{NA}
\end{alltt}


{\ttfamily\noindent\bfseries\color{errorcolor}{\#\# Error in grouse.counts[na.sites, ] <- NA: object 'grouse.counts' not found}}\begin{alltt}
\hlstd{grouse.umf}\hlopt{@}\hlkwc{y} \hlkwb{<-} \hlstd{grouse.counts}
\end{alltt}


{\ttfamily\noindent\bfseries\color{errorcolor}{\#\# Error in eval(expr, envir, enclos): object 'grouse.counts' not found}}\end{kframe}
\end{knitrout}
  \pause
  \vfill
  Fit the models again
  \vspace{-6pt}
\begin{knitrout}\scriptsize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fm1} \hlkwb{<-} \hlkwd{pcount}\hlstd{(}\hlopt{~}\hlstd{temp} \hlopt{~} \hlstd{elevation.s}\hlopt{+}\hlstd{utmE.s}\hlopt{+}\hlstd{utmN.s, grouse.umf,} \hlkwc{K}\hlstd{=}\hlnum{50}\hlstd{)}
\hlstd{fm2} \hlkwb{<-} \hlkwd{pcount}\hlstd{(}\hlopt{~}\hlstd{temp} \hlopt{~} \hlstd{elevation.s}\hlopt{+}\hlstd{utmN.s, grouse.umf,} \hlkwc{K}\hlstd{=}\hlnum{50}\hlstd{)}
\hlstd{fm3} \hlkwb{<-} \hlkwd{pcount}\hlstd{(}\hlopt{~}\hlstd{temp} \hlopt{~} \hlstd{elevation.s, grouse.umf,} \hlkwc{K}\hlstd{=}\hlnum{50}\hlstd{)}
\hlstd{fm4} \hlkwb{<-} \hlkwd{pcount}\hlstd{(}\hlopt{~}\hlnum{1} \hlopt{~} \hlstd{elevation.s}\hlopt{+}\hlstd{utmN.s, grouse.umf,} \hlkwc{K}\hlstd{=}\hlnum{50}\hlstd{)}
\hlstd{fm5} \hlkwb{<-} \hlkwd{pcount}\hlstd{(}\hlopt{~}\hlnum{1} \hlopt{~} \hlstd{elevation.s, grouse.umf,} \hlkwc{K}\hlstd{=}\hlnum{50}\hlstd{)}
\hlstd{fm6} \hlkwb{<-} \hlkwd{pcount}\hlstd{(}\hlopt{~}\hlnum{1} \hlopt{~} \hlnum{1}\hlstd{, grouse.umf,} \hlkwc{K}\hlstd{=}\hlnum{50}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}
\pause
\vfill
Put models in a \inr{fitList}
  \vspace{-6pt}
\begin{knitrout}\scriptsize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{grouse.models} \hlkwb{<-} \hlkwd{fitList}\hlstd{(}\hlstr{'lam(elev+utmE+utmN)p(temp)'}\hlstd{=fm1,}
                         \hlstr{'lam(elev+utmN)p(temp)'}\hlstd{=fm2,}
                         \hlstr{'lam(elev)p(ptemp)'}\hlstd{=fm3,}
                         \hlstr{'lam(elev+utmN)p(.)'}\hlstd{=fm4,}
                         \hlstr{'lam(elev)p(.)'}\hlstd{=fm5,}
                         \hlstr{'lam(.)p(.)'}\hlstd{=fm6)}
\end{alltt}


{\ttfamily\noindent\bfseries\color{errorcolor}{\#\# Error in fitList(`lam(elev+utmE+utmN)p(temp)` = fm1, `lam(elev+utmN)p(temp)` = fm2, : could not find function "{}fitList"{}}}\end{kframe}
\end{knitrout}
\end{frame}




\begin{frame}[fragile]
  \frametitle{Model selection in `unmarked'}
  \small
  Create AIC table
\begin{knitrout}\scriptsize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{modSel}\hlstd{(grouse.models)}
\end{alltt}


{\ttfamily\noindent\bfseries\color{errorcolor}{\#\# Error in modSel(grouse.models): could not find function "{}modSel"{}}}\end{kframe}
\end{knitrout}
  \pause
  \vfill
  We could use the model with the lowest AIC for inference and
  prediction. \\ 
  \pause
  \vfill
  Or, we could model-average the predictions, which we'll cover later
  in the course. \\
  \pause
  \vfill
  For now, let's use the top model to predict grouse abundance across
  N Georgia.
\end{frame}


\subsubsection{Spatial prediction}


\begin{frame}
  \frametitle{Spatial prediction}
  When our covariates are available as raster layers, we can paint our
  predictions across the landscape. \\
  \pause
  \vfill
  This doesn't account for spatial autocorrelation, except through the
  covariates, but it can be very useful nonetheless for modeling
  species distributions. \\
  \pause
  \vfill
  We will cover spatial autocorrelation later. 
\end{frame}



\begin{frame}[fragile]
  \frametitle{Spatial prediction}
\begin{knitrout}\scriptsize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(raster);} \hlkwd{library}\hlstd{(sf)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Registered S3 method overwritten by 'sf':\\\#\# \ \ method \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ from \ \ \ \ \ \ \\\#\# \ \ plot.sfc\_MULTIPOLYGON R\_GlobalEnv}}

{\ttfamily\noindent\bfseries\color{errorcolor}{\#\# Error: package or namespace load failed for 'sf' in dyn.load(file, DLLpath = DLLpath, ...):\\\#\# \ unable to load shared object '/home/rchandler/R/x86\_64-pc-linux-gnu-library/4.1/sf/libs/sf.so':\\\#\# \ \ libgdal.so.27: cannot open shared object file: No such file or directory}}\begin{alltt}
\hlkwd{load}\hlstd{(}\hlstr{"state_boundaries.gzip"}\hlstd{)}
\hlstd{elev} \hlkwb{<-} \hlkwd{raster}\hlstd{(}\hlstr{"elev_utm16.tif"}\hlstd{)}
\hlkwd{plot}\hlstd{(elev,} \hlkwc{main}\hlstd{=}\hlstr{"Elevation"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=0.8\linewidth]{figure/elev-sp-1} 

}


\begin{kframe}\begin{alltt}
\hlkwd{plot}\hlstd{(ga.nc.sc.tn.utm,} \hlkwc{add}\hlstd{=}\hlnum{TRUE}\hlstd{)}
\end{alltt}


{\ttfamily\noindent\bfseries\color{errorcolor}{\#\# Error in CPL\_geos\_is\_empty(st\_geometry(x)): could not find function "{}CPL\_geos\_is\_empty"{}}}\end{kframe}
\end{knitrout}
\end{frame}




\begin{frame}[fragile]
  \frametitle{Spatial prediction}
%  Extract UTM northing:
\begin{knitrout}\scriptsize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{utmN} \hlkwb{<-} \hlstd{elev}
\hlstd{utmN[]} \hlkwb{<-} \hlkwd{yFromCell}\hlstd{(elev,} \hlkwc{cell}\hlstd{=}\hlnum{1}\hlopt{:}\hlkwd{length}\hlstd{(elev))}
\hlkwd{plot}\hlstd{(utmN,} \hlkwc{main}\hlstd{=}\hlstr{"UTM northing"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=0.8\linewidth]{figure/utmN-sp-1} 

}


\begin{kframe}\begin{alltt}
\hlkwd{plot}\hlstd{(ga.nc.sc.tn.utm,} \hlkwc{add}\hlstd{=}\hlnum{TRUE}\hlstd{)}
\end{alltt}


{\ttfamily\noindent\bfseries\color{errorcolor}{\#\# Error in CPL\_geos\_is\_empty(st\_geometry(x)): could not find function "{}CPL\_geos\_is\_empty"{}}}\end{kframe}
\end{knitrout}
\end{frame}



\begin{frame}[fragile]
  \frametitle{Spatial prediction}
  We have to standardize our rasters \alert{using the same mean and SD
    as used before}.  
\vspace{-6pt}
\begin{knitrout}\scriptsize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{attributes}\hlstd{(site.covs.s)[}\hlnum{3}\hlstd{]} \hlcom{## Means}
\end{alltt}
\begin{verbatim}
## $`scaled:center`
##         utmE         utmN    elevation 
##  778580.9217 3852681.1770     666.1218
\end{verbatim}
\begin{alltt}
\hlkwd{attributes}\hlstd{(site.covs.s)[}\hlnum{4}\hlstd{]} \hlcom{## SDs}
\end{alltt}
\begin{verbatim}
## $`scaled:scale`
##      utmE      utmN elevation 
## 36537.870 18030.242   186.605
\end{verbatim}
\end{kframe}
\end{knitrout}
\pause
\vfill
\begin{knitrout}\scriptsize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{elev.s} \hlkwb{<-} \hlstd{(elev}\hlopt{-}\hlnum{666.1}\hlstd{)}\hlopt{/}\hlnum{186.6}
\hlstd{utmN.s} \hlkwb{<-} \hlstd{(utmN}\hlopt{-}\hlnum{3852681.2}\hlstd{)}\hlopt{/}\hlnum{18030.2}
\end{alltt}
\end{kframe}
\end{knitrout}
\pause
\vfill
Put them together in a `raster stack'
\vspace{-6pt}
\begin{knitrout}\scriptsize
\definecolor{shadecolor}{rgb}{0.878, 0.918, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{elev.utm} \hlkwb{<-} \hlkwd{stack}\hlstd{(elev.s,utmN.s)}
\hlkwd{names}\hlstd{(elev.utm)} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"elevation.s"}\hlstd{,} \hlstr{"utmN.s"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Spatial prediction}
























































